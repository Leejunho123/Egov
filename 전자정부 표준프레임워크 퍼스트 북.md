# 전자정부 표준프레임워크 퍼스트 북 
### https://www.egovframe.go.kr/home/ntt/nttRead.do?menuNo=65&bbsId=4&nttId=1449

1. 전자정부 표준프레임워크
    + 공공사업에 적용되는 SW 프레임워크의 표준을 정립
    + 응용 SW 표준화
    + 품질 및 재사용성을 높일 수 있는 기반 제공
    
    1. SW 프레임워크 등장배경
        - 메인프레임 시대부터, Client/Server, 시대의 전환인 WEB의 등장 모바일/클라우드 시대까지 변화해오면서, 이제는 누구나 소프트웨어를 사용하고, 사용해야만 생활할 수 있는 시대가 되었다. 최근 들어서는 twitter, Facebook 등 소셜미디어의 등장으로 거대한 데이터들이 날마다 생산. 이러한 데이터를 분석, 활용/처리 하는 데 IT 업계의 대표적인 이슈
        - 가장 중요시 되던 부분 : 자동화, 재사용
        - 기술 발전으로 실시간 처리와 일괄 처리로 구분.
        - 소프트웨어 규모의 대형화 및 복잡화 -> 개발 비용 증대
        - 일관되지 않은 개발 방식 -> 유지보수성 악화
        - 새로운 기술 교육 및 훈련 부족 -> SW 개발 및 운영에 많은 문제점 발생.
        - 이 원인들로 다양한 발전이 있었음

        1. 소스 재사용
            - 초보적인 재사용 방식으로 과거 코드를 복사해서 사용
        2. 재사용 메소드
            - 복사/붙이기 방식과 동일한 코드가 여러 클래스에서 나오는 것을 지양
            - 라이브러리로 만들어 재사용하는 방식
        3. 재사용 객체
            - 기존의 재사용방식 - 소스 재사용, 재사용 메소드 - 들은 자바뿐만 아니라 다른 언어를 사용할 때도 가능한 방식이나, 확장이 쉽지 않은 방식이었다면, 자바 언어에서는 클래스는 설계하고 상속, 확장하는 방식으로 재사용을 진행.
        4. 디자인패턴
            - 클래스의 재사용 방식이 객체의 수직적인 재사용 방식, 디자인 패턴은 상황적인 문제를 해결해주는 재사용 방식.
            - 메커니즘의 재사용으로 진행
        5. SW 프레임워크
            - 디자인 패턴은 상황에 대한 해결이 가능. 시스템 전체에 대해서는 직접 패턴을 적용하여 문제를 해결.
            - 이러한 문제점을 해결하기 위해 전체 시스템적 관점에서 표준화된 디자인 패턴을 적용한 설계 및 구현체가 SW 프레임워크
    2. SW 프레임워크 정의
        - SW 프레임워크의 사전적 의미 : 무엇을 이루는 뼈대 혹은 기반 구조.
        - 개발을 도와주는 부분부터 사상에 이르기까지 다양한 범위로 논의.
        - 소프트웨어 시스템에 대한 라이브러리 또는 클래스의 재사용 세트
        - 소프트웨어의 특정 클래스에 대한 재사용 가능한 디자인을 구성하는 클래스틀 협력의 집합 - GoF 패턴
        - 종합 정의
            - 일련의 문제 해결을 위한 추상화된 디자인을 구현한 클래스들의 집합으로 클래스 보다는 큰 규모의 재사용을 지원
            - 구체적이며 확장 가능한 기반 코드, 설계자가 의도하는 아키텍쳐와 디자인 패턴 집합
            - 실전에서 얻은 최적화 개발 경험을 반영한 재사용 가능한 API집합
            - 라이브러리와 달리 어플리케이션의 틀과 구조를 결정, 그 위에 개발된 개발자의 코드를 제어하는 반 제품 성격의 소프트웨어
            
        - 장점
            - 개발용이성
            - 시스템 복잡도의 감소
            - 이식성
            - 품질보증
            - 운영 용이성
            - 개발코드의 최소화
            - 변경용이성
            - 설계와 코드의 재사용성
            
    3. 표준프레임워크 개요
        - 표준프레임워크 전 전자정부 지원사업 시에 대기업의 SW 프레임워크가 도입 활용.
        - 그로 인한 문제점 : 폐쇄적 정책. 자사 SW 프레임워크를 공개, 판매 하지 않아 상호호환성을 보장하기가 어려움
        - 따라서 연속 사업 혹은 유지보수사업의 사업자 변경을 원칙적으로 어렵게 한다는 문제가 있었다.
        - 이미 특정 SW 프레임워크를 활용하여 구축된 소스코드를 다른 SW 프레임워크로 변경이 불가능하기 때문에 SW 프레임워크의 적용은 불가피하게 소스 코드의 종속성 문제를 가지게 됨.
        - 결국 공동 SW 프레임워크 필요성
        - 표준프레임워크는 실행, 개발, 관리, 운영 등 4개의 환경 과 모바일 표준프레임워크, 공통컴포넌트로 구성.
        - 참조프레임워크로 대표적인 오픈소스 SW프레임워크인 스프링 프레임워크 채택
        - OSS를 적용/ 활용하여 구성
        - 전자정부 서비스의 품질향상, 정보화 투자 효율성 향상을 달성
        - 대,중소기업이 동일한 개발기반 위에서 공정 경쟁이 가능하게 된다.
        - 표준프레임워크는 기존 다양항 플랫폼 환경을 대체하기 위한 표준은 아니며, java 기반의 정보시스템 구축에 활용할 수 있는 개발,운영 표준 환경을 제공하기 위한 것.
        - 공공 정보화 사업에 많이 활용되는 인프라 환경과의 호환성 보장
        - 광범위한 보급-확산을 위해 소스 뿐만 아니라 분석-설계 산출물도 함께 공개
        - 다수가 만족하는 표준이 될 수 있도록, 개발 과정에서 다양한 전문가로 구성된 협의회 의견을 청취-반영
        

    4. 표준프레임워크 활용 고려 사항
        1. 자바 기반의 웹 응용 시스템(WAS가 존재하는 경우)
        2. (2.7 기준) JavaEE(J2EE) 5 혹은 JDK1.5 이상의 환경 (단, 개발환경 2.7 이상에서는 JDK 1.6이상 필요)...
        3. 신규 개발시스템으로써, 기존 시스템과 물리적 혹은 논리적으로 구분되는 경우
        
        + 표준프레임워크는 표준으로써 목적을 만족하기 위하여 아래의 규칙을 준수하여 적용
            - 실행환경은 원칙적으로 변경 없이 활용해야 함
            - 개발환경은 기능의 변경과 추가에 제약사항 없음
            - 공통컴포넌트는 변경 가능하나, 표준프레임워크 아키텍쳐 준수 필요
            

2. 개발환경 구성하기
    1. 개발환경 구성
        - 구현도구, 테스트도구, 형상-변경관리 도구, 배포도구로 구성
            - 구현도구 : 프로그램 개발, 컴파일, 디버그 등 개발자 개별 환경 제공
            - 테스트도구 : 개발자가 단위테스트를 수행하고 결과를 리포팅
            - 형상-변경관리 도구 : 개발자가 작성한 소스코드를 통합하여 버전관리 수행
            - 배포도구 : 형상관리의 소스코드를 통합 빌드하고 개발 서버 등에 배포
        - 개발환경 : 개발자 PC에서 작업이 진행되는 개발자 개발환경과 개발서버 및 운영서버에서 진행되는 서버개발환경으로 구성
        - 개발자 : 개발 환경을 활용 소스코드를 제작, 컴파일 및 테스트를 구행하고 실행 가능한 형태로 빌드
        - 개발자 개인 별 소스코드를 수정하여 commit하거나 update하는 형태로 공동작업 형태 개발.
        - 배포도구는 통합저장된 소스코드를 불러와서 통합 빌드한다.
        - 웹 어플리케이션 서버 등에서 실행이 가능한 형태로 구조화하여 배포
        - 주요 오픈소스
            - 구현도구 : Eclipse, PMD, Maven
            - 테스트도구 : JUnit, EasyMock, DbUnit, EclEmma
            - 형상-변경관리도구 : Subversion, jTrac
            - 배포도구 : Hudson, Nexus, Maven
                - Eclipse : 자바 소스코드를 편집, 컴파일, 테스트, 실행이 가능하도록 지원하는 대표적인 개발도구
                - PMD : Eclipse 플러그인. 룰셋 기반으로 소스코드 오류 등을 검사하여 품질을 높이도록 한다.
                - Maven : 소스코드 컴파일에 필요한 라이브러리를 관리하고 컴파일, 테스트, 빌드 등 작업을 수행
                - JUnit : 단위테스트 코드를 작성하여 테스트하도록 지원한다.
                - EasyMock : 웹 어플리케이션을 실행하지 않고도 테스트가 가능하도록 시뮬레이션 환경을 지원
                - DBUnit : DB 테스트 데이터를 생성 결과가 미리 입력된 결과값과 같은지 비교할 수 있도록 환경 지원
                - EclEmma : 실제 소스 코드에서 단위테스트로 수행된 부분이 어느 정도인지 퍼센트 형태로 정보를 알려주는 coverage 테스트
                - Subversion : 형상관리도구. 소스 통합 버전관리
                - jTrac : 변경관리 이력 등을 추적 가능
                - Hudson : 지속적 테스트와 통합을 지원하는 CI 도구
                - Nexus : Maven 라이브러리 3rd Party로 제공시에 활용
   
            

    2. 개발환경 설치 및 구성
        - 프레임워크 홈페이지에서 제공하는 교육교재를 활용하는 방법 : 모두 구성. 활용 가능
        - 표준프레임워크에서 개발환경을 내려 받고 Tomcat,JDK 등 필요한 설정을 한다.
        - 기존에 활용하던 Eclipse에 표준프레임워크 플러그인을 설치하여 활용하는 방법
        1. 교육실습교재 사용
            - 교육자료 다운.
            - 표준프레임워크을 처음 사용하는 사용자나 자바에 익숙하지 않은 개발자들은 처음에는 이 방법을 활용하여 사용하는 것을 권장
            - 필요한 소프트웨어 및 설정이 되어 있어 바로 활용 가능
        2. 개발환경 구성
            - Tomcat 등등 다 설치해주고 연동까지 해줘야 한다.
        3. 기존 Eclipse에 플러그 인 설치
            - 개발은 가능. egovFrame전용 도구는 활용 불가.

3. 개발자 개발환경 활용
    1. 구현도구 활용
        - Eclipse Java EE를 기반으로 표준 프레임워크 플러그인이 설치되어 있다.
        - Eclipse 기본화면은 메뉴바, 툴바, 퍼스펙티브바, 4개의 뷰 영역으로 구성
        - 4개의 뷰를 포함하는 전체 영역을 퍼스펙티브, Eclipse Window 전체를 워크벤치라 부름
        - 구현도구는 통합메뉴, 퍼스펙티브, 뷰, 에디터 등을 제공
        - eGovFrame 퍼스펙티브를 선택하면, 메뉴에 eGovFrame 통합 메뉴가 나타나게 된다.
        - 통합메뉴는 유형별 프로젝트 생성, 각종 다이어그램 작성, SQLMap 편집, 공통컴포넌트 생성 등 기능을 제공.
    2. Maven 활용
        1. 라이브러리 의존성 관리
            - 기존에 개발된 수많은 라이브러리를 활용하여 필요한 기능을 쉽게 확장할 수 있다는 장점
            - 종속성 및 버전관리가 어려운 문제
            - 특징 라이브러리를 활용하기 위해서는 참조하고 잇는 다른 라이브러리도 함께 활용이 되어야 한다.
            - A라는 라이브러리가 B와 C라이브러리 기능을 활용하고 있다면 A만 가지고는 활용이 불가능. B,C를 함께 참조
            - 버전 문제
            - 이 모든 라이브러리의 Build Path를 개별적으로 설정은 불가능
            - Maven은 이러한 라이브러리 관리 문제를 해결하기 위해 의존성 설정을 활용하여 라이브러리를 관리
            - 실제 pom파일 dependency가 의존성 설정인데 모든 jar가 들어가 있지 않다. 이는 특정 라이브러리를 다운받을 때 그 라이브러리에도 pom 파일이 존재하여 그 안의 버전에 따른 다른 라이브러리 또한 다운받기 때문. 이는 Maven local repository에 저장되어 있다.
            - pom dependency 예제
                ```
                <dependency>
                 <groupId>egovframework.rte</groupId>  라이브러리 식별 namespace
                 <artifactId>egovframework.rte.ptl.mvc</artifactId>  라이브러리 명
                 <version>{egovframework.rte.version}</version>  버전정보
                 <exclusions>  옵션이며, 충돌 등의 이유로 특정 라이브러리 의존성 제거
                 <exclusion>
                 <artifactId>commons-logging</artifactId>
                 <groupId>commons-logging</groupId>
                 </exclusion>
                 </exclusions>
                </dependency>
                ```
            - 처음 Maven 실행 시 Local Repository에 라이브러리가 없다면 pom.xml의 repository에 기술된 Remote Repository로부터 라이브러리를 다운받게 된다. 사용자가 Nexus 등을 활용하여 개별적 3rd Party 라이브러리를 구성할 수도 있다. 인터넷이 차단된 폐쇄망에서는 필수적으로 별도 Repository를 구성해야함
        2. 빌드 관리
            - Maven에서는 디렉터리 구조를 정규화. 복잡한 설정 없이 컴파일, 패키징 등을 수행가능.
            - 실제 소스파일, 테스트 소스 파일로 구성. resources 디렉터리에는 jar나 war로 패키징 될 때 함께 배포되어야 할 설정파일 등의 리소스가 위치
            - 웹 프로젝트의 경우 webapp 밑에 MVC 설정과 웹 리소스 (HTML, 자바스크립트, 이미지 등)가 위치.
        3. Maven 설정
            - pom.xml : 프로젝트의 정보, 의존성, 빌드 세팅(플러그인) 정보를 포함하고 있다. Maven 프로젝트는 빌드 되어 로컬 또는 원격 Repository에 배포될 수 있기 때문에 자체적으로 GroupId, Artifact Id, 버전 정보를 가짐.
            - 라이브러리 관리를 위한 의존성 관리
            - 컴파일, 패키징 뿐만 아니라 테스트 결과 리포트, java doc 생성과 같은 작업들을 플러그인 설정을 통해서 수행 가능.
            - Maven 은 빌드 작업시에 플러그인을 활용하여 생명주기 단계별로 플러그인을 바인딩하여 작업을 처리.
            - 플러그인의 설정은 pom.xml의 pluginManagement 에 기술.
            - 표준프레임워크에서 설정하여 제공하고 있는 주요 Maven 플러그인 정보
                - complie : maven-compiler-plugin : 소스코드 컴파일
                - test : maven-test-plugin, maven-surefire-plugin : 단위테스트 실행과 리포트 생성
                - package : maven-jar-plugin, maven-war-plugin : 압축파일 생성
                - emma : maven-emma-plugin : Code coverage report 생성
            - maven build 시 모든 필요한 소스들 다운로드
            - maven install 시 compile, test, package, install의 순서로 실행
                - compile : resources 플러그인이 실행, 소스 코드가 copy, compiler 플러그인이 동작하여 컴파일을 수행
                - test : test 플러그인이 실행, 단위테스트 수행, surefire 플러그인을 통해 테스트 결과 리포트 생성
                - package : war 플러그인이 동작되어 war 배포파일 생성.
                - install 단계에서 로컬 repository로 배포.

4. 서버 개발환경 활용
    1. 형상관리 도구 활용
        1. Subversion 개요 및 설치
            + 형상관리 도구는 팀프로젝트 수행시에 개인 개발자들이 작성한 소스코드를 하나의 프로젝트로 통합.
            + 변경된 내용을 버전관리하여 변경 히스토리를 관리하고 필요한 경우 이전 버전으로 변경할 수 있도록 기능을 지원.
            + Subversion은 파일 뿐 아니라 디렉터리도 버전관리를 지원. 변경관리를 변화된 부분만 관리하여 성능이 우수.
            + 윈도우 환경의 서버 VisualSVN을 활용하면 SubVersion을 쉽게 설치할 수 있음.
        2. Revisions
            + 저장소에 저장된 각각의 파일 버전.
            + Commit 시에 일정한 규칙에 의해서 숫자가 증가.
            + Subversion은 변경 발생 시에 전체 단위로 Revision을 갱신하여 관리.
            + 개발 파일 단위로 Revision을 관리하게 되면 전체적으로 소스코드에 변경이 일어난 순서 정보를 알기 어렵게 됨.
        3. Eclipse와 연동
            + Subversion을 활용하기 위해 제일 먼저 해야 하는 일은 프로젝트 최초 commit하는 것.
            + 최초 commit이 되어 Subversion repoistory에 저장.
            + 다른 개발자들이 자신의 workspace로 내려 받아 활용 가능 이를 check out.
            + 그 후에는 commit, update
            + 종종 충돌 가능. 다시 Commit or Update 하면 됨 (Override and Commit, Override and Update)

    2. 배포 도구 활용
        1. CI 개요 및 설치
            - 전통적으로 SW 개발은 분석, 설계, 개발, 테스트의 순서로 진행
            - 프로젝트의 위험 요소는 에러, 미개발, 요구사항 미 충족 등의 결함이 프로젝트 후반 특히 오픈 직전에 발견
            - 이러한 문제를 해결하기 위해 소스코드 통합과 테스트를 상시적으로 수행하는 개념이 CI이다.
            - 많은 개발자로 구성된 팀이 작업한 것을 짧은 주기로 통합 및 테스트를 수행하는 소프트웨어 개발 방식이다.
            - commit -> 형상관리 서버에서 통합 -> check out -> Maven 등 도구 활용하여 테스트 및 빌드.
            - 주로 Maven package를 수행하여 테스트 및 배포파일 생성. 개발서버 배포
            - 라이브러리 : Maven deploy를 실행하여 Nexus 등의 원격 Repository로 배포할 수 있다.
            - CI 서버로는 Hudson이 많이 활용되었으나 Sun이 Oracle로 흡수 합병에 따라 기존 Hudson 오픈소스 프로젝트에 변경이 생기면서 Jenkins 프로젝트가 시작되었다.
            - Hudson도 Eclipse에서 오픈소스 프로젝트로 개발이 진행 중에 있으나 Jenkins보다 업데이트 등이 활발하지 못한 상태.
            - 두 개의 CI서버는 거의 동일한 기능을 가지고 있기 때문에 굳이 구별할 필요는 없지만, 사용성 및 향후 발전 측면에서는 Jenkins가 더 유리한 상태이므로 Jenkins 기준으로 설명.
            - war파일 Tomcat 등의 WAS 의 webapp 밑에 압축을 풀어 주는 것으로 설치가 완료.
            - Hudson의 경우도 마찬가지로 설치가능.
            - Jenkins의 경우 WAS까지 패키징하여 윈도우, 맥 등의 실행파일 형태로 설치할 수 있도록 지원하고 있다.
            - 이 경우 별도의 WAS의 설치가 불필요하여 편리하지만 OS에서 자동 실행되는 서비스로 등록되기 때문에 개발 및 테스트 용도로는 관리가 어려울 수 있다.
           
            
            

5. 실행환경 소개
    1. 실행환경 구성
        + 실행환경은 화면처리, 업무처리, 데이터처리, 연계, 공통기반, 배치처리 Layer로 구성
            + 화면처리 Layer : 사용자 인터페이스 및 화면 구현에 필요한 기능과 구조 제공
            + 업무처리 Layer : 예외 처리 및 업무흐름 처리 기능을 제공
            + 데이터처리 Layer : 개발자가 작성한 소스코드를 통합하여 버전관리 수행
            + 연계 Layer : SOAP기반 웹 서비스 기능 제공
            + 공통기반 Layer : 재사용 컴포넌트, 로그 등 개발에 필수적인 기능 제공
            + 배치처리 Layer : 일괄처리를 위한 설정 및 실행 기능 제공
            
        + 실행환경 Layer별로 하위 서비스를 제공. 화면처리 Layer의 경우 기본 패턴인 MVC이외에 국제화, Ajax, 국제화 등 기능을 제공.
        + 데이터처리 Layer 의 경우에는 DB 접속을 위한 DataSource
        + SQL을 XML 설정파일에서 관리 할 수 있도록 지원하는 Data Access
        + 자바코드로 SQL을 대신할 수 있는 ORM 서비스
        + 공통기반 레이어에는 표준 패턴을 제공하는 IOC,AOP와 Logging 등 서비스를 제공
        ![image](https://user-images.githubusercontent.com/73324807/114120956-7ecc6c80-9928-11eb-9710-6d952c20b5e7.png)
        + 표준프레임워크 실행환경에서 서비스 별로 채택 활용하고 있는 대표적은 오픈소스는 다음과 같다.
        ![image](https://user-images.githubusercontent.com/73324807/114120982-88ee6b00-9928-11eb-8ab5-65a70c463d48.png)
        + 표준프레임워크 주요 패턴과 기능은 Spring 프레임워크 기반으로 구성.
        + Spring 프레임워크 : Java 웹 어플리케이션 개발을 쉽게 해주는 오픈소스 SW 프레임워크이다.
        + 인터페이스와 구현으로 구성된 자바 객체는 Spring 컨테이너에 빈 형태로 등록되어 활용된다.
        + Spring 프레임워크는 IoC 컨테이너로 구성되는 CORE, DB를 지원하는 DAO, JPA 등 ORM 메시징 등 Enterprise 환경을 지원하는 JEE, 웹 환경을 지원하는 WEB의 패키지로 구성된다.
        ![image](https://user-images.githubusercontent.com/73324807/114120834-4036b200-9928-11eb-83f9-a6b03da297ae.png)
        ![image](https://user-images.githubusercontent.com/73324807/114120909-68261580-9928-11eb-8667-69019426562d.png)

6. DI
    + 자바프로그래밍 시 구현된 기능을 다른 소스코드에서 활용할 때 설정되어 있는 소스코드 간의 종속성 부분은 재사용에 큰 어려움을 주게 된다.
    + 이러한 문제를 해결하기 위해 DI를 활용하여 소스코드간에 직접적으로 종속성을 가지지 않고, 참조 정보를 XML 설정파일이나 annotation을 활용하도록 한다. -> 소스코드를 직접 고치지 않고 소스코드를 참조할 수 있도록 지원
    1. 자바 인터페이스
        + 자바 인터페이스는 클래스들이 구현해야 하는 동작을 지정하는 데 사용되는 추상형, 클래스들이 지켜야 하는 형식을 정의
        + 인터페이스는 클래스에서 외부로 노출되어 활용되는 변수나 메소드 정보를 제공하여 다른 클래스에서 쉽게 참조할 수 있도록 한다.
        + 그리고, 현재의 클래스를 다른 클래스로 대체하기 위해 반드시 구현이 필요한 메소드 정보를 제공한다.
        + 인터페이스에 있는 메소드만 구현이 되면 클래스를 다른 클래스로 교체하여 사용할 수 있다.
        + 일반적으로 컴포넌트를 구성할 때 인터페이스와 클래스를 묶어서 구성하게 된다.
        + 컴포넌트는 특정한 기능을 다른 기능으로 쉽게 대처할 수 있도록 구성이 되어야하기 때문에 인터페이스 정보는 필수적이다.
        + 외부의 다른 클래스에서 활용가능한 메소드는 인터페이스에 기술되어 있기 때문에 인터페이스에 있는 정보만 참조하면 된다.
        + 인터페이스를 활용하여 클래스 정보의 추상화, 캡슐화가 가능하다.
        + 그림에서 NameServiceImpl 클래스에 많은 메소드가 있지만 NameService 인터페이스를 Type으로 활용하고 클래스 인스턴스를 생성하게 되면 다른 메소드들은 참조할 수 없고, 인터페이스에 기술된 getName()만 참조가 가능하다.
        + 자바에서 클래스 인스턴스를 생성할 때 별도 인터페이스를 생성하지 않고 클래스 자체를 Type으로 생성할 수 있으나, 인터페이스를 활용하는 경우 다른 클래스에서 참조 가능한 메소드만 표현하고, 다른 메소드들은 노출시키지 않아도 되기 때문에 활용이 편리하다.
        
        ![image](https://user-images.githubusercontent.com/73324807/114121018-960b5a00-9928-11eb-946d-e1d63b33a443.png)

        
        + 인터페이스는 동작에 관련된 처리 로직 등의 코드가 포함되어 있지 않고, 구현을 위한 메소드 명, 입출력 Type 등 형식만 정의한다.
        ![image](https://user-images.githubusercontent.com/73324807/114135629-771ac100-9944-11eb-9bc0-aea918e7ead5.png)

        
        + 앞의 설명에서 String 값의 id를 입력 변수로 가지고, 결과값을 String 값으로 반환하는 getName() 메소드를 가지는 NameService 인터페이스는 다음과 같이 작성된다.
        ![image](https://user-images.githubusercontent.com/73324807/114135646-7eda6580-9944-11eb-9ee0-35470b51d7f6.png)

        
        + 클래스는 인터페이스 정보를 참조하여 정의되어 있는 메소드는 반드시 구현해야 한다. 만약 구현하지 않으면 에러가 발생된다. NameService 인터페이스를 참조하여 구현한 NameServiceImpl 클래스는 다음과 같이 작성된다.
        ![image](https://user-images.githubusercontent.com/73324807/114135659-8732a080-9944-11eb-8256-c0a641ced938.png)

        
        + NamerServiceImpl의 메소드를 다른 클래스는 NamerServiceApp에서 참조하기 위해서 NamveService 인터페이스를 Type 으로 가지는 클래스 인스턴스와 클래스자체를 Type으로 가지는 클래스 인스턴스를 생성하면 다음과 같다.
       ![image](https://user-images.githubusercontent.com/73324807/114135695-96b1e980-9944-11eb-9362-81c19a4ebbd1.png)

        
        + 하나의 클래스에 여러 개의 인터페이스를 활용하는 경우 클래스의 메소드를 호출하는 클래스에 따라 다르게 노출시킬 수 있다. 이 경우에는 어떤 인터페이스를 Type으로 활용하여 클래스 인스턴스를 생성하는지에 따라 외부에 어떤 메소드가 노출되는 지 결정된다. 그림은 하나의 클래스 NameServiceImpl에 두 개 의 인터페이스를 활용하는 형태이다. CustomerService 인터페이스에서 getCustomer()만 메소드로 가지고 있기 때문에 CustomerService를 Type으로 생성된 클래스 인스턴스에서는 getCustomer()만 호출하여 활용이 가능하다. 이 경우 Class에서 제공하는 메소드를 호출 활용하는 클래스에 따라 다르게 노출시켜 활용할 수 있도록 캡슐화 하게 된다.
        ![image](https://user-images.githubusercontent.com/73324807/114135732-a5000580-9944-11eb-89ad-24e4d4a41db8.png)
        
        + 자바 인터페이스를 활용하는 다른 사례로는 하나의 인터페이스에 클래스가 다수 존재하는 경우
        + 흔히 컴포넌트를 만드는 가장 중요한 이유로는 현재 구현된 기능을 다른 기능으로 쉽게 교체하여 활용할 수 있도록 하는 것
        + 인터페이스를 같은 것으로 활용하는 클래스가 있다면 기존 코드의 수정 없이 그대로 교체하여 활용할 수 있다.
        + 컴포넌트 기반의 개발에서는 인터페이스를 잘 설계하고 이를 활용하여 개발하는 것이 중요
        + 인터페이스가 잘 설계되어 있으면 특정한 기능의 모듈을 상황에 따라 교체하여 활용하는 것이 가능해진다.
        + 대표적인 예로 JDBC 드라이버의 경우 Oracle, MySQL 등 활용하는 DB가 달라져도 같은 역할을 수행해야 하므로 인터페이스를 준수하는 것이 필수적이다. 다음과 같이 두 개의 클래스 OracleImpl과 MySQLImpl가 하나의 인터페이스 DBService 인터페이스에 정의된 두 개의 함수 connect와 select는 반드시 구현이 되어야 한다. 하나의 인터페이스를 참조하고 있기 때문에 두 개의 클래스는 서로가 교체가 되어도 다른 코드에는 영향을 미치지 않게 된다.
        + 만약 인터페이스를 Type으로 선언하지 않고, 클래스로 Type을 선언하였다면 클래스를 교체할 때 두 개의 클래스 Type이 동일해야만 하는 지를 먼저 확인해야 한다. 클래스 Type이 일치하는 경우는 클래스 전체 함수나 변수 등이 일치해야 되기 때문에 새로운 동일 Type 클래스를 작성하거나 Type이 같은 지를 확인하는 작업은 인터페이스를 활용하는 경우에 비해 매우 어렵다.
        ![image](https://user-images.githubusercontent.com/73324807/114135779-b6e1a880-9944-11eb-92b5-4b071d6e8bb2.png)

        
        
    2. DI개념
        + 인터페이스를 활용하는 경우 동일한 Type을 유지할 수 있어 컴포넌트 구현과 활용에 유리하다.
        + 특정한 클래스를 활용하다가 비즈니스 로직 변경 필요 등의 이유로 다른 클래스로 교체해야하는 경우가 발생될 수 있다.
        + 보편적인 방법은 new로 생성된 클래스를 직접 변경하는 것이다.
        + 만약 참조하고 있는 클래스가 수십개, 수백개가 되는 경우 굉장히 어려운 작업이 될 것이다.
        + 만약 클래스의 소스코드가 없는 경우는 어떻게 해야할 것인가? 
        + 이 때 등장한 개념이 DI(Dependency Injection)
        + DI는 클래스 인스턴스를 생성할 클래스를 직접 소스코드에 지정하지 않고 인터페이스를 활용하여 Type만 지정한다.
        + XML설정파일이나 annotation을 활용하여 실제 인스턴스를 생성할 클래스를 지정하게 된다.
        + 만약 다른 클래스로 교체를 해야 되는 경우에는 소스코드를 수정할 필요가 없이 XML 설정 팡리이나 annotation 정보를 수정하여 적용이 가능하다. Spring을 활용하지 않는 일반 자바 환경이라면 컴파일시에는 에러가 발생되지 않으나, 실행 시에 Class Not Found 에러가 발생하게 된다.
        + Spring이 동작하면서 설정파일이나 Annotation에 등록된 클래스 정보를 읽어서 동작시점에 Dependency를 생성하게 된다.
        + DI를 활용해서 소스코드에서 new를 해주는 것과 같은 효과를 어플리케이션이 동작하는 시점에 동적으로 생성할 수 있다. 그림에서 DI를 활용하지 않을 때는 new의 형태로 클래스 인스턴스를 생성하게 되어 있어 다른 클래스로 교체하기 위해서는 소스코드 수정이 필요하다. DI를 활용하는 경우에는 XML설정이나 annotation을 변경하여 Mapping정보를 변경하는 형태로 소스코드 변경이 없이 다른 클래스로 교체가 가능하다. 비즈니스 로직 변화가 많은 환경에서 소스코드의 수정없이 변경에 유연해진다. 클래스가 다른 클래스들 간의 의존성을 소스코드 레벨에서 가지지 않고 설정파일을 변경하여 의존성 변경이 가능해진다. 특정한 기능을 컴포넌트 형태로 만들어서 쉽게 교체해야 되는 경우 효율적으로 활용될 수 있다.
        ![image](https://user-images.githubusercontent.com/73324807/114135816-c19c3d80-9944-11eb-926a-bfeae1b5e591.png)
        + Spring Container는 객체를 생성하고, 객체 간의 의존성을 이어줄 수 있도록 필요한 정보를 제공
        + 이러한 객체를 Bean이라고 부르며, Spring 프레임워크에서 동작하는 모든 객체는 Bean단위로 활용된다.
        + 어플리케이션이 동작하는 시점에 XML이나 annotation으로 설정된 정보를 Spring Container에 저장하고, 설정 정보를 활용하여 DI를 수행하여 결과적으로 Spring에서 활용가능한 객체 형태인 bean을 생성하게 된다.
        + 소스코드 레벨에서는 클래스가 어떤 클래스를 참조하고 있는 지 알 수 없고, 어플리케이션이 동작하는 시점에 설정파일을 통해서 클래스에 대한 의존성이 결정되게 되므로 이를 IoC(Inversion of Control)이라고 한다.
        + 클래스 의존성의 결정이 소스코드에 있지 않고 외부에서 결정되어 활용되는 형태로 일반적인 어플리케이션이 동작과 반대되는 개념으로 IoC(제어의 역전)라고 불린다.
        ![image](https://user-images.githubusercontent.com/73324807/114135829-c8c34b80-9944-11eb-99de-aee221227fd5.png)
        + Spring Container의 정보는 ApplicationContext에 의해 관리된다. ApplicationContext는 Bean 생성 및 DI, 생명주기를 관리하는 BeanFactory의 기능과 Spring AOP, 메시지 리소스 처리, 이벤트 처리 등의 기능을 제공. ApplicationContext는 BeanFactory의 기능을 모두 제공하므로 일반적으로 ApplicationContext를 활용한다. Spring Container 정보를 생성하고 "foo"라는 bean을 찾는 방법은 다음과 같다. 다수의 Spring 설정 파일(Bean 설정, AOP 설정, 트랜잭션 설정, Data source 설정 등)을 일겅서 context를 생성하여 활용한다.
        ![image](https://user-images.githubusercontent.com/73324807/114135851-cfea5980-9944-11eb-8e42-cb50e79ef9b8.png)
        

    3. DI 활용
        + DI를 설정하기 위해 활용하는 방법으로 XML을 활용하는 방법과 annotation을 활용하는 방법
        + XML을 활용하는 방법은 설정이 불편하고 어려운 단점, XML 파일만 분석시 모든 클래스들 간의 의존성을 파악할 수 있는 장점
        + Annotation의 경우 소스코드에 annotation이 산재되어 있어 의존성 파악은 어려운 점, 편리한 설정 활용.
        + XML 설정의 경우 Spring 기반으로 구현된 솔루션, 플러그인, 프레임워크 등을 활용할 때 많이 활용되고, 일반 비즈니스 로직 구현은 annotation을 활용하는 것이 일반적이다.
        + 서비스 클래스는 비즈니스 로직을 처리하는 클래스.
        + DAO는 DB와 연동하여 정보를 처리하는 클래스로 표준프레임워크에서는 MyBatis(이전 버전 iBatis)를 활용하여 DB작업을 수행.
        ![image](https://user-images.githubusercontent.com/73324807/114135873-d8db2b00-9944-11eb-9257-094cedb00f5a.png)
        + 비즈니스 로직인 웹 어플리케이션의 경우 Controller클래스에서 호출된다. 제일 처음 해야할 것은 인터페이스 구현.
        ![image](https://user-images.githubusercontent.com/73324807/114135896-ded10c00-9944-11eb-9c6f-5144bef8ee36.png)
        1. XML 설정을 활용한 DI
            + XML 설정파일은 <beans/>를 root로 가지며, <bean/>을 사용하여 의존성을 설정한다.
            + Spring Container에 여러 설정파일을 읽어 활용할 수 있기 때문에 설정 내용이 너무 많은 경우에는 XML 설정을 여러 개의 파일로 구성한다. 또한, DI, AOP, 트랜잭션, 메시지 등 설정 내용에 따라 개별 파일을 구성하는 것이 일반적이다. 다음의 XML설정은 두 개의 bean을 설정하고 있다. Bean은 id를 가지고 실제 클래스를 Mapping하고 있다. 클래스 정보는 Spring Container에 id와 함께 저장되어 어플리케이션이나 다른 bean에서 bean의 id로 해당 클래스 정보를 요청할 때 정보를 제공하게 된다. customerXML의 id를 가지는 bean은 실제 lab.CustomerXMLServiceImpl 클래스이며, property속성(custXMLDAO)이 정의 되어 bean id가 customerXMLDAO bean을 레퍼런스(ref)하고 있으며, 서비스 클래스에서 DAO클래스를 참조하기 위한 DI설정에 활용된다. 레퍼런스 되는 Bean은 id가 custoemrXMLDAO이고, 클래스는 lab.CustomerXMLDAO로 Mapping 되어 있다. Property이름은 클래스에서 클래스 정보를 받아오기 위해 정의하는 setter method에서 첫 글자를 대문자로 바꾸어 메소드 명으로 활용된다. 설정에서 customerXML의 경우 CustomerXMLServiceImpl 클래스의 setter 메소드 명으로 setCustXMLDAO으로 정의한다.
            ![image](https://user-images.githubusercontent.com/73324807/114135937-ec869180-9944-11eb-824a-ff6ac8dee6c5.png)
            
            + XML로 DI를 설정하는 클래스 CustomerXMLServiceImpl은 인터페이스를 참조하여 구현되며, 인터페이스에 설정된 두 개의 메소드 getCustName과 getCustGrade를 반드시 구현해야 한다. DAO를 호출하여 전달 받은 결과 값을 반환하도록 구현 되었다. private CustoemrXMLDAO xmlDAO; 로 Type만 선언되어 있고, new로 인스턴스 생성이 되지 않았는데 xmlDAO.getCustName(id)의 형태로 메소드를 호출하고 있다. Spring을 쓰지 않는 환경이라면 실행시점에 Class Not Found 에러가 발생되는데, DI를 활용하여 설정에 있는 클래스 정보를 setter method에서 치환하여 new를 실행한 것과 같이 인스턴스를 생성하게 된다. setCustXMLDAO에서 cmlDAO의 변수로 XML설정파일에 property로 설정 되어 있는 클래스 정보 (lab.CustomerXMLDAO)를 읽어와서 매핑하게 된다.
            
            ![image](https://user-images.githubusercontent.com/73324807/114135955-f4463600-9944-11eb-9c96-3bf1cd0f108f.png)
            
            + DAO는 서비스에서 호출되어 전달 받은 문자 값에 “ eGovFrame XML”과 “ S XML”을 추가하여 반환하도록 되어 있다. XML설정에는 bean id가 customerXMLDAO로 설정되어 있고, 실제 클래스는 lab.CustomerXMLDAO이며 DI를 위해 서비스 클래스에 property 속성으로 레퍼런스 되어 있다.
            ![image](https://user-images.githubusercontent.com/73324807/114135984-fdcf9e00-9944-11eb-88be-3dcdecbe8d1a.png)
        2. Annotation 설정을 활용한 DI
            + Annotation은 소스코드에 직접 코딩을 하는 것이 아니라 @의 형태로 메타데이터를 삽입하는 것을 의미한다. 비즈니스로 로직에는 영향을 주지 않고 소스코드에 대한 실행이나 설정 정보를 추가한다. Annotation을 활용하여 DI를 설정하기 위해서는 Spring에서 annotation 활용을 위한 component-scan 정보를 설정해주어야 한다. Spring Container가 실행 될 때 base package 하위 소스코드의 Annotation 정보를 읽어서 Spring Container에 저장한다. 아래 설정(context-common.xml)에서는 패키지 lab 이하의 모든 소스코드를 스캔하여 annotation 정보를 획득하여 Spring Container에 저장하게 된다.
            
            ![image](https://user-images.githubusercontent.com/73324807/114136019-07f19c80-9945-11eb-8818-4020653a928b.png)

            
            + Bean을 설정하기 위해 클래스 위에 역할별로 annotation을 기술한다. 비즈니스 로직을 구현하는 서비스 클래스는 @Service, DAO는 @Repository로 정의 한다. MVC에서 소개하게 되는 Controller 클래스에는 @Controller를 정의한다. Bean 이름은 @Service(“customer”) 와 같이 정의하며, 이름이 지정되지 않으면 클래스 이름의 첫 글자를 소문자로 바꾸어 자동으로 지정한다. 설정된 bean 정보를 활용하여 DI를 설정하기 위해서는 @Resource나 @Autowired를 활용한다. Private CustomerAnnotationDAO customerdao;의 형태로 Type이 지정되어 있으나 new로 인스턴스를 생성하지 않고, @Resource(name=”custoerdao”)의 형태로 DI를 수행하였다. @Resource의 경우에는 bean의 이름을 지정하여 DI가 가능하며, @Autowired의 경우에는 같은 Type (Interface)를 활용하는 class를 자동으로 매핑하여 DI를 수행한다. 같은 Type이 다수 존재하는 경우는 에러가 발생되므로 유의하여야 한다. XML설정과 annotation설정을 통한 DI는 서로 교차도 가능하다. 즉 XML로 설정된 bean을 annotation을 활용하여 DI를 설정할 수 있고, 반대로 annotation으로 설정된 bean을 XML을 활용하여 DI 설정할 수 있다. Annotation을 활용한 DI 설정은 다음 그림과 같다. @Controller, @Service, @Repository로 bean이 설정되어 있고, 이를 DI로 활용하기 위해 @Resource로 참조 설정 되었다.
            
            ![image](https://user-images.githubusercontent.com/73324807/114136049-150e8b80-9945-11eb-9b9c-6cb6317ff75e.png)
            
            + @Service를 활용하여 customer 이름으로 bean이 설정되어 있다. Customerdao 이름으로 설정된 DAO bean을 활용하기 위해 @Resource로 참조 설정 하였다.
            
            ![image](https://user-images.githubusercontent.com/73324807/114136080-1dff5d00-9945-11eb-80e5-2f6bc19115f2.png)

            
            + @Repository를 활용하여 customerdao 이름으로 bean이 설정되어 있다. 서비스 클래스에서 @Resource로 참조 설정되고 메소드 호출 된다.
            ![image](https://user-images.githubusercontent.com/73324807/114136098-25266b00-9945-11eb-99bd-1e47650e6e68.png)
            
        3. Client 어플리케이션 실행
            + CustomerXMLServiceImpl이 동작하는지 확인하기 위해서 getCustName과 getCustGrade를 호출하는 자바 어플리케이션을 작성 한다. 자바 어플리케이션은 만들어진 서비스를 활용하는 Client 역할을 수행하기 때문에 XML이나 Annotation을 통한 DI 설정을 하지 않고, Spring Container에서 bean을 검색하여 정보를 얻어오는 형태로 활용하게 된다. XML이나 Annotation을 활용하여 DI설정을 하는 경우는 클래스간 연관이 높으면서 변경 가능성이 있는 경우에 변경 유연성을 높이기 위해서이다. 다른 클래스에서 기능만 호출하여 사용하는 경우는 연관성을 없애는 것이 중요하다. 이러한 경우 CustomerServiceApp 클래스 에서와 같이 Spring Container에서 bean id로 검색하고 bean 정보를 얻어오게 지원하면 기능 제공자와 사용자 간의 loosely coupling 된 형태로 의존성을 없애고 유연하게 활용할 수 있다.
            ![image](https://user-images.githubusercontent.com/73324807/114136132-353e4a80-9945-11eb-9296-bff1569011b3.png)
            ![image](https://user-images.githubusercontent.com/73324807/114136173-412a0c80-9945-11eb-82a0-778ee8067c70.png)

            + 어플리케이션을 실행하면 다음과 같이 결과가 출력되는 것을 확인할 수 있다. XML에서는 id를 “1”로 전달 했고, annotation에서는 id를 “2”로 전달하여 서비스 클래스와 DAO 클래스를 거쳐서 결과 값을 전달 받았음을 확인 할 수 있다. 빨간색으로 에러 표시가 되는 부분은 로그를 생성할 log4j파일이 없어서 발생되는 것으로 제7장에서 학습하게 되며, 실행에는 지장이 없다.
            
            ![image](https://user-images.githubusercontent.com/73324807/114136196-4c7d3800-9945-11eb-85b0-0d8a85e942ff.png)

            
        4. Test 코드 실행
            + 단위테스트는 소스코드의 중요 로직의 메소드를 실행시켜서 결과를 확인 할 수 있도록 한다. 메소드의 실행결과가 특정한 값으로 예상되는 경우 일치하는지 여부를 확인하여 일치하면 테스트가 Pass 되어 아무런 메시지가 출력되지 않지만, 일치하지 않는 경우는 에러메시지를 출력하게 된다. 이를 위해 표준프레임워크에서는 JUnit을 활용하여 테스트 케이스를 작성하여 실행한다. 먼저, spring-test와 JUnit 라이브러리 설정을 확인하여야 한다. pom.xml에 다음과 같이 의존성 설정이 되어 있는지 확인한다.
            ![image](https://user-images.githubusercontent.com/73324807/114136225-54d57300-9945-11eb-9ffb-64b512a2fbd8.png)
            + Maven 기반 디렉터리 구조에서 테스트를 위해 src/test/java와 src/test/resources가 정의되어 있다. Test 코드는 src/test/java 밑에 위치하게 되며, 테스트에서 활용되는 설정파일은 src/test/resources 밑에 정의되어야 한다. 따라서 src/main/resources에 있는 설정파일을 src/test/resources 밑으로 copy해야 한다. Spring 프레임워크에서 JUnit을 지원하기 위해 Spring Container를 실행할 수 있도록 annotation 기반 기능을 제공하고 있다. @RunWith은 Spring 기반으로 JUnit을 실행하도록 Runner를 지정하는 역할을 하고 있다. @ContextConfiguration은 경로에 해당되는 설정파일을 읽어서 Spring Container를 생성하여 JUnit 테스트 프로그램에서 접근하여 활용될 수 있도록 한다. 테스트케이스들은 @Test의 형식으로 설정되어 메소드를 직접 호출하지 않아도 JUnit이 실행될 때 자동으로 실행된다. 테스트 결과를 판별하기 위해 수행이 정상적일 때 결과값과 실제 수행된 결과값을 비교하여 두 개가 같을 경우에는 아무런 동작도 하지 않으나, 다를 경우 테스트 실패라는 에러 메시지를 출력하게 된다. assertEquals의 경우 예상 결과 값과 실제 수행된 결과 값을 비교하여 두 값이 다를 경우 에러메시지를 출력한다. 이외에도 assertNotEquals, assertTrue, assertFalse, assertNull, assertNotNull 등 많은 메소드를 제공하고 있다. 테스트를 수행하기 전후에 데이터의 준비, 결과값 처리 등 필요한 작업이 있을 경우 테스트케이스 수행 전 후에 자동으로 실행 될 수 있도록 @BeforeClass, @AfterCalss, @Before, @After의 annotation을 제공하고 있다. JUnit에서 활용되는 annotation들은 다음 표와 같다.
            
            ![image](https://user-images.githubusercontent.com/73324807/114136239-5bfc8100-9945-11eb-8c06-3034a1e99972.png)
            + 앞에서 어플리케이션으로 실행되었던 Customer서비스 실행을 JUnit으로 실행하게 되면 다음과 같다. @ContextConfiguration에서는 test 환경에서 활용될 설정 파일 위치를 지정하게 되며, src/test/resources 밑의 설정 정보를 읽어오게 된다. JUnit이 실행되게 되면 @Test로 설정되어 있는 테스트케이스가 실행되게 되며, assertEquals가 실행되어 예상 값과 결과 값을 비교하여 결과를 출력하게 된다.
            ![image](https://user-images.githubusercontent.com/73324807/114136268-6585e900-9945-11eb-9feb-dfda81d46151.png)
            + 테스트 코드의 실행은 CustomerServiceTest.java를 선택하고 마우스 오른쪽 버튼을 눌러서 Run As > JUnit Test를 선택하여 실행한다. 테스트가 성공한 경우에는 아무런 출력이 없이 녹색 막대가 보여지게 된다. 테스트가 실패한 경우에는 실패 메시지와 함께 빨간색 막대를 보게 된다. 테스트 실패의 경우는 에러가 발생된 경우와 정상적으로 실행은 되었으나 assert 문의 조건을 만족하지 못하는 경우 발생된다. (assertEquals의 경우 예상 값과 수행 결과 값이 다른 경우 실패)
            ![image](https://user-images.githubusercontent.com/73324807/114136294-6f0f5100-9945-11eb-9e6e-2c6780990f01.png)
            ![image](https://user-images.githubusercontent.com/73324807/114136305-759dc880-9945-11eb-8e65-567c7255fbfd.png)




7. Logging
    + 표준프레임워크에서 Log정보 참조를 위해 콘솔화면, File, DB를 활용할 수 있도록 log4j기반으로 기능을 제공하고 있다.
    + Log4j는 설정을 통해 개발자에게 필요한 정보를 출력할 수 있도록 설정할 수 있으며, Log레벨 조정을 통해서 필요한 정보가 전달 될 수 있도록 지원한다. 개발 시에는 DEBUG레벨로 상세한 정보를 참조하고 운영 시에는 불필요한 메시지가 출력되지 않도록 INFO, ERROR 레벨로 조정하여 소스코드 수정 없이 설정파일의 수정만으로 제어가 가능하다.
    1. Logging 개요
        + Logging은 시스템의 개발이나 운영 시에 발생할 수 있는 어플리케이션 내부 정보에 대해서 시스템의 오부 저장에 기록하거나 화면 등에 출력하여 디버그 또는 시스템의 상황 파악을 쉽게 할 수 잇도록 지원하는 서비스이다. 디버그를 위해 System.out.println()을 사용하기도 하는데 예제 프로그램 등 간단한 거이 아닌 실제 프로젝트 환경에서는 사용하지 말아야한다. System.out.println()을 호출하게 되면 디스크 I/O 동기화 처리가 되기 때문에 전체적인 시스템의 성능이 저하될 수 있고, System.out.println()으로 디버그 처리한 부분을 일일이 주석처리, 해제를 하는 것은 개발 및 운영의 효율성을 떨어트릴 수 있다. 표준프레임워크에서는 Apache log4j를 활용하여 logging을 지원.
            + 서브시스템(패키지) 별로 상세한 Log 정책 부여
            + 날짜형식, 시간형식 등 다양한 형식의 Log 메시지 형태 지정
            + 다양한 매체(File, DB, Mail 등)에 대한 Log 관리 기능
            + 레벨(debug, info, warn, error 등) 별로 로그를 기록
        + 표
            + Logger : Log파일을 작성하는 클래스로 Log를 기록할 대상을 패키지 또는 클래스 이름으로 지정하고 이에 대한 로그레벨과 Appender를 지정
            + Appender : Log를 출력하는 위치로 화면, 파일, DB 등 지정. 화면출력의 경우 console 지정.
            + Layout : Appender의 출력 포맷으로 날짜, 시간, 클래스명 등의 정보를 Log 내용으로 지정
        
        + Logger에서 Log레벨을 지정할 수 있으며, 지정된 Log 레벨보다 높은 메세지도 함께 출력
        + ex) Log 레벨이 ERROR이면  ERROR 이외 메시지는 출력되지 않는다. 레벨이 DEBUG로 지정되면 레벨이 높은 INFO, WARN, ERROR 메시지도 함께 출력된다. 개발 시에는 Log 레벨을 DEBUG로 두고 메소드 실행결과 등 확인이 필요한 Log를 출력하고, 실제 운영 시에는 Log 레벨을 INFO로 두고 중요 정보 확인 및 에러 메시지 등을 관리하는 것이 일반적이다.
        + 표
            + Error : 처리 중 문제가 발생한 상태
            + Warn : 처리 가능한 문제이지만, 향후 시스템 에러의 원인이 될 수 있는 경고성 메시지
            + Info : 로그인, 상태 변경 등 정보성 메시지
            + Debug : 개발시 디버그 용도로 사용할 메시지
            
    2. Log4j 활용
        + Log4j를 활용하기 위해서는 egovframe.rte.fdl.logging 참조 가능하도록 설정이 필요.
        + pom.xml에 직접 설정하지 않아도 전자정부 표준프레임워크에서 반드시 설정이 필요한 egovframe.rte.psl.dataaccess 와 egovframe.rte.ptl.mvc 참조설정을 하면 의존성 설정에 의해서 자동으로 설정이 된다.
        + Log4j-core-2.1.jar 및 log4j-api-2.1.jar 등 필요 라이브러리 의존성이 설정되어 있는 것을 확인할 수 있다. 아래 설정은 egovframe.rte.fdl.logging에 설정되어 있는 내용과 개발 환경에서 설정된 라이브러리 화면이다.
        
        ![image](https://user-images.githubusercontent.com/73324807/114141623-d086ee00-994c-11eb-8f4d-86e137296aa6.png)
        
        + Log4j 활용을 위해서는 Logger, Appender 를 설정하는 설정파일(log4j2.xml)이 필요하다.
        + 설정파일은 src/main/resources 밑에 위치한다. 설정파일에 Default로 설정되는 logger는 Root level로 표현된다.
        + ERROR가 default 레벨로 표시되어 logger가 지정되지 않으면 Error 레벨의 Log만 출력.
        + Spring 프레임워크에서 출력하는 메시지는 logger명이 "org.springframework"로 되어 있고 INFO 레벨로 지정되어 있다. 소스코드에 해당되는 logger 이름은 "lab"으로 되어 있고 레벨은 INFO로 설정되어 있다.
        ![image](https://user-images.githubusercontent.com/73324807/114141648-d977bf80-994c-11eb-8337-b534e18a6ed7.png)

        
        + Log를 출력하기 위해서는 먼저 LogManager의 getLogger() 메소드 호출을 통해 Log 출력에 활용할 logger를 설정해주어야 한다. getLogger()는 static 메소드이므로 인스턴스 생성을 하지 않고 호출이 가능하다. getLogger()에 string 값이 입력되면 입력 값에 해당되는 Logger를 활용할 수 있게 된다. Null 값이 입력되면 Class 이름이 입력된다. 앞에서 logger의 이름을 "lab"으로 입력하였기 때문에 getLogger("lab")이라고 입력을 해도 되지만, getLogger(.class.getName())의 형태로 패키지와 클래스네임을 입력하도록 하면 패키지 이름이 입력되어 logger "lab"을 입력한 것과 같게 된다. Logger가 설정되면 출력하고자 하는 Log레벨을 지정하고 출력하고자 하는 메세지를 Log로 출력한다.
        ![image](https://user-images.githubusercontent.com/73324807/114141679-e3012780-994c-11eb-888d-a73deba96274.png)
        ![image](https://user-images.githubusercontent.com/73324807/114141705-ec8a8f80-994c-11eb-9f18-a2e03cb15896.png)





8. AOP(Aspect Oriented Programming)
    + 프로그램 개발할 때 로깅, 트랜잭션, 예외처리 등 반복적 처리가 되어야 하고, 업무 로직 코드와 혼재되어 전체적으로 소스코드가 복잡해지고 특정 라이브러리에 의존성도 발생되게 된다. 이러한 문제를 해결하기 위해 기술적인 처리가 필요한 영역을 별로 공통모듈로 분리하고 대상과 발생시키는 시점을 정의하여 자동적으로 실행될 수 있도록 하여 변경이 용이하고 재사용성을 높일 수 있도록 한다.
    1. AOP 개요
        + AOP는 객체지향 프로그래밍을 보완하는 개념으로 어플리케이션을 객체지향적으로 모듈화하여 작성하더라도 다수의 객체들에 분산되어 중복적으로 존재하는 공통모듈이 여전히 존재. 이를 AOP에서는 횡단관심이라고 부른다. 업무 처리를 하는 모듈(주된 관심, primary concern)에서 로깅, 보안, 트랜잭션, 예이처리 등의 기술적인 처리를 수행하기 위한 소스코드가 포함이 되어 업무 로직에 집중하기가 힘들다. 또한, 기술적 처리를 위한 모듈 들과의 의존성이 생겨 어플리케이션 변경 시에 유연성이 떨어진다. 일반 어플리케이션 환경과 AOP가 적용된 환경을 비교해 보면, AOP가 적용되지 않으면 모듈안에 주된 관심과 횡단 관심이 섞여 존재하게 된다. 그림에서처럼 업무 모듈에 기술적 처리를 위한 cross concern이 섞여서 존재한다. AOP를 활용하면 기술적 처리를 위한 모듈을 advice로 분리하여 별도로 존재하게 한다. 별도로 존재하는 advice가 필요한 시점에 동작할 수 있도록 동작하는 대상과 동작되는 시점을 규칙형태로 정의한다.
        ![image](https://user-images.githubusercontent.com/73324807/114148275-89046000-9954-11eb-8ec4-bdeb98058e9f.png)
        + 예를 들어 로그를 처리하기 위해 log4j를 활용한다면 log4j 모듈에 대한 의존성이 생기게 되며, 업무 처리 모듈에서 로그를 출력하기 위한 소스코드가 포함되게 된다. 이러한 문제를 해결하기 위해서는 기술적 처리를 위한 cross concern을 advice로 별도로 분리하고, 업무처리 모듈 중에 어느 메소드(point cut)에서 어느 시점(joint point)에 처리를 해야 되는지를 규칙형태로 정의한다. 정해진 규칙에 해당되게 되면 advice의 정해진 메소드가 실행된다.
        ![image](https://user-images.githubusercontent.com/73324807/114148309-928dc800-9954-11eb-9c7d-8d528f6dade6.png)
        + 그림에서 일반 어플리케이션은 모든 모듈이 log4j에 의존성을 가지고 있으나, AOP를 활용하게 되면 분리된 advice에만 log4j의존성을 가지게 되며, 주된 관심인 업무 모듈에서 cross concern인 log4j를 호출하는 모듈을 포함할 필요가 없어진다. 정해진 규칙에 해당하게 되면 자동으로 실행되도록 한다.
        ![image](https://user-images.githubusercontent.com/73324807/114148359-9f122080-9954-11eb-86b3-25287fdb326d.png)

        + AOP를 활용하여 얻게 되는 효과
        ![image](https://user-images.githubusercontent.com/73324807/114148413-adf8d300-9954-11eb-9bb6-0c064f953eed.png)

    2. XML을 활용한 AOP 설정
        + AOP 활용을 위해 설정파일에 advice, point cut, joint point를 설정한다. 파일명은 임의로 정의를 해도 되지만 구분을 위해 주로 context-advice.xml로 명명한다. 설정은 aop라는 prefix를 활용하여 설정을 한다. *lab..*Impl.*(..)의 표현은 lab 패키지 밑에 Impl로 되어 있는 모든 클래스의 모든 메소드에 대해서 AOP를 적용한다는 것이다. Joint point의 설정은 before, after-returning, after-throwing, after, around에 대해서 각각 해당되는 poing cut id를 지정하고 실행할 advice의 메소드를 지정한다. Before joinit point의 경우 point cut은 "targetMethod"이고 메소드가 실행되기 전에 "beforeTargetMethod"가 실행되게 된다. After_returning의 경우 "afterReturningTargetMethod"가 실행되며 결과값을 "retVal" 변수로 받아오게 된다. 로그 등을 출력하는 등 결과 값을 활용할 경우 사용된다.
        ![image](https://user-images.githubusercontent.com/73324807/114148446-b81ad180-9954-11eb-8368-2e8068a5665f.png)
        ![image](https://user-images.githubusercontent.com/73324807/114148468-c0730c80-9954-11eb-85ea-1d3a2d2ebe24.png)

        + 앞에서 설명된 여러 지정자를 활용하여 Point cut을 설정하는 예제를 보면 다음 표와 같다. 정의 예제에서 execution은 메소드를 지정하고 within은 타입을 기준으로 설정하는 차이가 있다. Execution을 사용하게 되면 메소드별로 AOP를 설정하게 되고, within은 인터페이스 별로 설정하게 된다. Execution에서 모든 메소드를 선택하게 되면, within으로 설정한 것과 같은 형태로 동작하게 된다. 또한, 두 개 이상의 표현식이 조합이 되어 활용 될 수 있다. IF문처럼 and (&&), or (||), not (!)의 연산자를 활용하여 point cut을 정의 할 수 있다.
        ![image](https://user-images.githubusercontent.com/73324807/114148509-cf59bf00-9954-11eb-9e29-8704b3866bd4.png)
        ![image](https://user-images.githubusercontent.com/73324807/114148536-d8e32700-9954-11eb-9b5d-6f4085be8c90.png)

    3. Advice 설정
        + AOP설정을 위해 AdviceUsingXML advice를 설정하였다. Advice에서 before, After-returning 등의 Joint point에서 실행될 메소드를 정의한다. Before의 경우 메소드가 수행되기 전에 실행되며, 메소드가 호출되어 전달 되는 인수(argument)의 값을 호출하여 받아 올 수 있다. 소스코드에서 before는 해당 클래스 및 메소드 이름을 출력하고, 전달 받은 인수 값을 출력한다. Advice가 실행되면 "Advice Using XML beforeTargetMethod" 가 출력되고 클래스명과 메소드명이 출력된다. 전달 받은 인수가 있는 경우에 인수 값도 함께 출력된다.
        ![image](https://user-images.githubusercontent.com/73324807/114148590-e698ac80-9954-11eb-80b2-fc1dc7a879a0.png)
        + After returning의 경우 메소드 실행이 정상적으로 실행된 후에 수행된다. 결과 값은 XML 설정에 returning으로 명시된 변수로 전달 받게 된다. 소스 8-1에서 retVal로 정의되었다.
        ![image](https://user-images.githubusercontent.com/73324807/114148624-ef897e00-9954-11eb-811e-afa4c7cf3829.png)
        + After throwing advice는 메소드 실행 중 에러 등의 예외 사항이 발생되었을 때 수행되며, exception 내용을 전달 받는다.
        ![image](https://user-images.githubusercontent.com/73324807/114148653-f7e1b900-9954-11eb-9829-25064779f4f4.png)
        + After는 메소드 실행 후에 정상종료 및 예외발생 등 결과에 상관없이 무조건 수행된다. IF문에서 finally와 비슷한 역할을 하며, 주로 리소스 해제 작업과 같은 마무리 작업을 위해 활용한다.
        ![image](https://user-images.githubusercontent.com/73324807/114148686-0039f400-9955-11eb-837c-d9f968eaa00a.png)
        + Around는 메소드 실행 전후에 수행된다. 결과 값을 변환해야 될 경우 활용한다. 결과 값을 전달 받아서 가공한 후 리턴할 수 있다. Proceed() 앞은 메소드 실행 전에 수행이 되고, 뒤는 메소드가 실행된 다음에 수행된다.
        ![image](https://user-images.githubusercontent.com/73324807/114148715-07f99880-9955-11eb-914f-a7a056334274.png)
        + Point cut의 메소드가 실행될 때 joint point에 따른 advice 실행순서를 정리해보면 다음과 같다. 정상실행과 예외발생의 경우 모두 before, around (실행 전)의 순서로 수행이 되며, 대상 메소드가 실행된 후에 정상실행의 경우 around(실행 후), after, after-returning의 순서로 실행이 된다. 예외 발생의 경우는 after를 실행하고 after-throwing을 실행하고 종료하게 된다.
        ![image](https://user-images.githubusercontent.com/73324807/114148736-0f20a680-9955-11eb-8772-7acbb037d1bb.png)
    4. AOP 활용 및 실행결과
        + sayHello()와 sayError()의 두 개의 메소드를 가지는 HelloWorldServiceImpl 서비스를작성하였다. HelloWorldApp에서 호출되어 실행되는 형태이며, sayHello()는 message를 인수로 받아서 문자열을 생성하여 결과를 출력하게 된다. Before advice에서 전달 받는 인수를 출력하게 되어 있어 내용 확인이 가능하며, After returning에서 결과 값을 리턴 할 때 결과를 출력하게 되어 있어 결과 확인이 가능하다. sayError()는 After throwing이 제대로 수행되는지를 확인하기 위해 고의로 0으로 나누어 에러를 발생시켰다.
        ![image](https://user-images.githubusercontent.com/73324807/114148760-16e04b00-9955-11eb-9f40-871a98a56cdf.png)

        + 실행하기 전에 주의할 점은 예제에서 해당 advice에서 로그를 출력하도록 되어 있는 debug 레벨로 설정되어 있어 로그레벨이 Debug로 되어야 확인이 가능하다. HelloWorldApp을 선택하고 Run As > Java Application을 선택하여 실행하면 다음과 같은 결과를 얻는다.
        ![image](https://user-images.githubusercontent.com/73324807/114148788-1fd11c80-9955-11eb-9447-79e3dc93410e.png)
    5. 표준프레임워크에서 Exception 처리 AOP 활용
        + 표준프레임워크에서 예외 처리를 위해서 AOP를 활용하고 있다. AOP를 활용하지 않으면 모든 메소드에서 예외처리를 중복적으로 구현해야 하는 불편함이 있다. 특히, 예외 종류에 따라서 처리가 다르게 수행해야 할 경우에는 메소드별로 중복적으로 관련로직을 개별 구현해야 한다. 예외 처리를 위한 advice에서는 예외가 BizException, Runtime Exception, 실행환경 Exception인지 예외 종류에 따라서 분기처리가 되어 다른 처리를 수행하게 된다.
        ![image](https://user-images.githubusercontent.com/73324807/114148823-295a8480-9955-11eb-896a-fe9703c47d24.png)

9. Data Access(MyBatis)
    + DB를 활용하여 데이터 연계를 하는 것은 정보시스템에서 필수적.
    + Java에서 제공하는 SQL 처리 기능을 활용 시 반복적인 코드 작성이 필요. SQL이 소스코드에 존재하여 변경이 유연하지 않고 관리가 어렵다.
    + MyBatis는 SQL을 별도 XML 파일에 위치. 간단하게 SQL을 실행할 수 있도록 지원
    1. MySQL DB 활용
        + DB프로그래밍을 위해서는 MySQL 설치와 활용이 필요하다. 표준프레임워크 교육 실습교재에 MySQL에 배포하고 있어 이를 활용하면 계정생성, DB생성 등 별도 작업없이 바로 쉽게 활용할 수 있다.
        ```
        create database com;
        create user 'com'@'%' identified by 'com01';
        GRANT ALL PRIVILEGES ON com.* TO 'com'@'%' WITH GRANT OPTION;
        ```
        ```
        접속 코드
        mysql -u아이디 -p비밀번호 DB
        
        create table customer(
        id varchar(10) primary key,
        name varchar(10),
        addr varchar(10));
        ```
   2. 자바 SQL 프로그래밍
       + DB 프로그래밍이 달라지는 점을 살펴보기 위해 일반적으로 자바에서 제공하는 SQL 프로그래밍 활용 방법.
       ![image.png](attachment:image.png)
           + JDBC(자바드라이버 규격)을 활용 DB에 연결하기 위해 JDBC가 클래스패스에 위치해야 한다.
           + JDBC는 DB마다 다르기 때문에 DB에 맞는 드라이버 활용.
           ```
           실제 java안에서 쓰는 SQL문
           Statement stmt = conn.createStatement();
           String sqlString = ("insert into customer values('"
           +request.getParameter("id")+"','"+request.getParameter("name")+"')";
           ```
           + INSERT 나 UPDATE에서 입력 값을 바꾸어 반복적으로 SQL을 실행하게 되는 경우에는 PreparedStatement를 쓰는 것이 성능이 우수.
           + Statement를 활용 시 DB에서 매번 새롭게 Parsing하기 때문에 성능이 저하. PreparedStatement를 활용하는 경우에는 SQL문에는 "?"로 변수 처리를 하로 setString을 활용하여 값을 대입.
           ```
           PreparedStatement pstmt = conn.prepareStatement("insert into customer values(?,?)");
           pstmt.setString(1,request.getParameter("id");
           pstmt.setString(2,request.getParameter("name");
           pstmt.executeUpdate();
           ```
           + INSERT, UPDATE, DELETE 등 SQL을 실행하여 전달받은 결과 값이 없는 경우에는 executeUpdate를 통해 실행.
           + SELECT의 경우 executeQuery를 실행 ResultSet 결과 값을 받음.
           + ResultSet은 커서 개념의 연결 포인터로 next() 메소드를 통해 다음 ROW로 이동하여 결과값을 전달.
           ![image-2.png](attachment:image-2.png)
           + ResultSet처리를 위해서 ResultSet에 결과 값이 없을 때까지 루프를 반복. getString() 또는 getInt()를 실행하여 값을 전달 받음.
           ```
           ResultSet rs = pstmt.executeQuery();
           while(rs.next()){
           id = rs.getString(1); // or rs.getString("id");
           name = rs.getString(2); // or rs.getString("name");
           }
           ```
           + 전체적인 자바 SQL을 활용하여 테이블에 값을 입력. 출력하는 방법은 다음과 같이 구현.
               + 실행하기 전 customer 테이블이 생성된 MySQL DB가 구동
               + MySQL JDBC드라이버(mysql-connector-java-5.1.42.jar)를 빌드패스에 등록
               + 실행하게 되면 customer 테이블에 배열로 표현된 3개의 레코드를 테이블에 INSERT하고 다시 SELECT를 수행.
               + INSERT 결ㄹ과를 System.out.println()으로 출력
               ```
               import java.sql.*;
               public class JDBCExample{
                   public static void main(String[] args){
                       try{
                           Class.forName("com.mysql.jdbc.Driver")
                       } catch (ClassNotFoundException e) {}
                       Connection conn= null;
                       try{
                           conn =  DriverManager.getConnection
                           ("jdbc:mysql"//localhost:3306/com","com","com01");
                           int[] id = {1,2,3};
                           String[] name = {"KIM","PARK","LEE"};
                           String[] addr = {"A","B","C"};
                           String sql = "INSERT INTO customer (id, name, addr) VALUES ( ?,?,?)";
                           PreparedStatement pstmt = conn.prepareStatement(sql);
                           for (int i=0; i < id.length; i++){
                               pstmt.setInt(1,id[i]);
                               pstmt.setString(2, name[i]);
                               pstmt.setString(3, addr[i]);
                               pstmt.executeUpdate();                            
                           }
                           
                       Statement stmt = conn.createStatement();
                       ResultSet rset = stmt.executeQuery("SELECT id, name, addr FROM customer");
                       while(rset.next()){
                           System.out.println("id: " + rset.getInt(1));
                           System.out.println("name: " + rset.getString(2));
                           System.out.println("addr: " + rset.getString(3));
                       }
                       } catch (SQLException e){
                           System.out.println(e.getMessage());
                       } finally {
                               if(conn != null) try
                                   { conn.close();
                                   } catch (SQLException e) {}
                       }
                   }
               }
               ```
               ![image-3.png](attachment:image-3.png)
    
    3. Data Source
        + DB에 연결하기 위해서 연결정보를 매번 입력. getConnection()명령어를 실행하여 connection을 생성하는 것은 매우 번거롭다.
        + Spring 프레임워크에서는 연결에 필요한 정보를 포함하여 DataSource Bean을 독립적인 객체로 생성하여 쉽게 DB연결이 가능하도록 지원
        + DataSource Bean은 사용하고자 하는 DB에 맞는 드라이버 명, 접속정보, 사용자, 패스워드 정보가 필요.
        + {driver}의 형태로 표시된 것은 별도 파일인 properites파일에서 값을 읽어오는 것이다.
        ```
        <bean id="dataSource"
            class = "org.springframework.jdbc.datasource.DriverManagerDataSource">
            <property name = "driverClassNmae" value="{driver}" />
            <property name = "url" value="{dburl}" />
            <property name= "username" value= "{username}" />
            <property name= "password" value="{password}"/>
        ```
        + Spring DataSource의 경우 연결이 필요한 경우 새롭게 세션을 생성하여 연결하게 되는데, 이 경우 연결에 소요되는 시간이 많이 소요되기 때문에 전체적인 DB처리 성능이 저하되게 된다. 새롭게 DB연결을 하게 되면 TCP/IP에 의해서 연결에 필요한 정보를 교환하게 되어 결과적으로 SQL에 소요되는 시간보다 새로운 연결을 생성하는 데 더 많은 시간이 소요될 수 잇다. 이러한 문제점을 해결하기 위해서 DB connection pool을 활용하는 것이 일반적이다. 오픈 소스 DB connection pool 중에 Apache의 DBCP가 많이 활용되고 있다. 실제 운영을 위해서 DB 성능은 미리 초기 및 최대 풀의 수와 관련이 있으며, 하드웨어 성능에 따라 최적의 값을 찾아내어 활용하는 것이 필요하다. 아래는 DBCP를 활용하기 위한 dataSource bean 설정 방법이다.
        
        ```
        <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
             destroy-method="close">
            <property name="driverClassName" value="{driver}" />
             <property name="url" value="{dburl}" />
             <property name="username" value="{username}" />
             <property name="password" value="{password}" />
             <property name="defaultAutoCommit" value="true"/>
             <property name="initialSize" value="5"/>
             <property name="maxActive" value="30"/>
             <property name="maxIdle" value="5"/>
             <property name="maxWait" value="30000"/>
             <property name="validationQuery" value="SELECT 1 FROM DUAL"/>
             <property name="testOnBorrow" value="true"/>
             <property name="testOnReturn" value="false"/>
             <property name="testWhileIdle" value="true"/>
             <property name="timeBetweenEvictionRunsMillis" value="60000"/>
            </bean> 
        ```
         + 설정된 Spring 또는 DBCP DataSource Bean은 @Resource나 @Autowired를 활용하여 DI를 통한 의존성 생성을 쉽게 활용할 수 있다.
         ```
         @Resource(name = "dataSource")
         DataSource dataSource;
         @Test
         public void testJdbcDataSource() throws Exception {
             Connection con = null;
             try { 
                 con = dataSource.getConnection();
                 stmt = con.createStatement();
                 rs = stmt.executeQuery("select 'x' as x from dual");
                 while (rs.next()){
                     assertEquals("x", rs.getString(1));....}
                     
             }
         }
         ```
         + Weblogic이나 JEUS와 같은 상용 WAS를 활용하는 경우에는 WAS에서 제공하는 connection pool을 활용하는 것이 바람직하다. JNDI(Java Naming Directory Interface)의 형태로 지정된 자원을 접근할 수 있도록 설정.
         ```
             <bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
                 <property name="jndiName" value="XACOM"/>
                 <property name="jndiTemplate" ref="jnditemplate"/>
             </bean>
             
             <bean id="indiTemplate" class="org.springframework.jndi.JndiTemplate">
                 <property name="environment"> <props>
                 <prop key="java.naming.factory.initial"> jeus.jndi.JNSContextFactory </prop>
                 <prop key="java.naming.provider.url"> localhost:9736 </prop>
             </props> </property> </bean>
         ```
         + JEUS에서 JNDI활용 Connection Pool 설정 
         ```
             <bean id = "dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
                 <property name="jndiName"> <value> oracle22Jndi</value></property>
                 <property name="jndiTemplate"> <ref local="dataSourceTemplate"/>
                 </property>
             </bean>
             
             <bean id = "dataSourceTemplate" class="org.springframework.jndi.JndiTemplate">
                 <property name="environment">
                 <props>
                     <prop key = "java.naming.provider.url"> t3://localhost:7001 </prop>
                     <prop key = "java.naming.factory.initial"> weblogic.jndi.WLInitialContextFactory</prop>
                 </props>
                 </property>
             </bean>
         ```
         + Weblogic에서 JNDI 활용 Connection Pool 설정
         
     4. Data Access (MyBatis)
         + Java SQL를 활용하여 DB프로그래밍을 할 경우에는 connection 객체 생성과 연결, 수행할 SQL의 준비와 실행, ResultSet을 활용한 결과처리 등 DB 처리가 될 때마다 비슷한 형태의 소스코드를 작성해야 한다. 개발자가 작성하는 소스코드가 많아 지면서 생산성도 떨어지게 되고 중요한 비즈니스 로직에 집중하지 못하는 문제가 생긴다.
         + SQL문이 소스 코드에 위치하기 때문에 SQL문 수정이 필요한 경우에는 소스코드를 수정하고 빌드와 배포를 다시 해야 하는 번거로움이 있다. 작업 종료시에 자원 반환 등의 처리를 실수로 누락하는 경우 당장 에러 등의 문제가 발생하지 않지만 리소스 손실 등으로 운영 중에 갑자기 서버에 장애가 발생할 수 있다. MyBatis를 활용하게 되면 실행한 SQL문은 XML로 작성된 설정파일 형태로 별도 저장된다. 따라서 SQL문을 수정할 경우 소스코드는 그대로 유지하고 XML로 작성된 설정파일 형태로 별도 저장된다. 따라서 SQL문을 수정할 경우 소스코드는 그대로 유지하고 XML파일만 바꾸면 되므로 변경이 수월 해진다. 또한 connection 연결 및 SQL문의 준비와 수행, 입력 파라미터 및 ResultSet의 매핑 등을 모두 MyBatis에서 처리하기 때문에 개발자가 처리해야할 부분이 적어져서 개발 생산성이 높아지고, 개발자의 실수에 의한 장애 발생 가능성도 줄어들게 된다. 만약 여러 DB 활용을 고려하여 프로그래밍을 해야할 경우 Java SQL를 활용할 경우 DB에 따라 별도 프로그램을 작성해서 관리해야 되기 때문에 불편하다. MyBatis의 경우 DB별로 실행할 SQL문을 XML파일로 작성하고 설정파일에 활용할 DB정보를 설정해주어 DB를 쉽게 변경 실행할 수 있다. MyBatis를 활용하기 필요한 구성요소로는 SQL문을 XML형태로 관리하는 Mapper파일이 있고, MyBatis 설정을 하는 Mapper Config 파일이 있다. Paremeter Object는 SQL문의 where절이나 INSERT, UPDATE 등에 필요한 값을 전달하게 된다. 클래스, MAP 모두 활용할 수 있는 데 주로 클래스를 활용한다. Result Object와 같이 클래스, Map 모두 활용 가능하다. 표준프레임워크에서는 context-mybatis.xml의 형태로 설정한다. 연결에 필요한 datasource 정보와 mapper config 파일 위치를 지정한다.
          ![image.png](attachment:image.png)
          ![image-2.png](attachment:image-2.png)
          
          + MyBatis를 활용하여 개발을 하기 위한 방법
              1. JDBC 드라이버 설치
                  + Maven 환경에서 DB 접속을 위해 pom.xml에 DB 드라이버의 dependency 설정이 필요하다.
                  + MySQL 드라이버의 dependency를 다음과 같이 설정한다.
                  ```
                  <dependency>
                      <groupId>mysql</groupId>
                      <artifactId>mysql-connector-java</artifactId>
                      <version>5.1.42</version>
                  </dependency>
                  ```
              2. SQL Mapper XML파일
                  + SQL Mapper XML 파일을 작성. Mapper XML파일에는 SQL마다 고유 id를 가지게 되며, DAO에서 SQL id를 호출하고 입력 값을 위한 Parameter 클래스를 전달하여 실행된다. Parameter Object는 mapper config에서 설정한 alias를 활용하는 것이 편리하다.
                  + 입력 값은 SQL안에 "{id}"의 형태로 설정되게 되며, 매핑을 위해서는 parameter Object의 멤버변수와 같게 이름을 적어야 한다. "id", "name", "address"의 멤버변수를 가지는 customerVO 클래스를 parameter Object로 활용한다면, SQL안에 입력 값을 매핑할 때 #{id}, #{name}, #{address}와 같이 기술하면 된다. 결과 값은 ResultMap으로 설정된 Result Object를 통해서 전달 받게 되며, mapper 파일 안에서 SQL실행 결과 컬럼 값과 Result Object 멤버 변수와 매핑 정보가 기술된다. Parameter Object와 마찬가지로 ResultMap은 mapper config에서 설정한 alias를 기술한다.
                  
                  ```
                  <?xml version="1.0" encoding="UTF-8"?>
                  <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
                  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
                  <mapper namespace="customer">
                  
                      <resultMap id="customerResult" type="customerVO">
                          <id property="id" column="id"/>
                          <result property = "name" column="name"/>
                          <result property = "address" column="addr"/>
                     </resultMap>
                     
                      <insert id="insertCustomer" parameterType="customerVO">
                          <![CDATA[
                              insert into customer (id, name, addr)
                              values (#{id}, #{name}, #{address})
                              ]]>
                      </insert>
                      
                      <select id="selectCustomerList" parameterType="customerVO"
                          resultMap = "customerResult"
                              <![CDATA[
                                  select id, name, addr
                                  from customer
                                  ]]>
                      </select>
                  </mapper>
                  ```
              3. SQL Mapper Config XML 파일
                  + My Batis 설정을 위해 필요한 파일이며, property, type alias, mappers, settings와 같은 정보를 가진다.
                  + Type alias 와 mappers 관련 정보만 설정하여 활용.
                  + Type alias는 mapper XML에서와 같이 Parameter Object 정보를 모두 기술하면 너무 길기 때문에 실제 클래스 정보는 Config 파일에만 기술하여 활용할 수 있도록 지원한다.
                  + Mappers 파일의 위치를 등록. 파일의 위치 * 등을 쓰지 않고, 정확하게 기술해 주어야 한다. Sqlsession에서는 mappers 파일의 위치를 * 등을 활용하여 설정할 수 있다.
                  ```
                  <?xml version="1.0" encoding="UTF-8"?>
                      <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
                      "http://mybatis.org/dtd/mybatis-3-config.dtd">
                      
                      <configuration>
                          <typeAliases>
                              <type Alias alias = "customerVO" type="lab.CustomerVO" />
                          </typeAliases>
                          <mappers>
                              <mapper resource = "META-INF/sqlmap/mappers/lab-dao-class.xml"/>
                          </mappers>
                      </configuration>
                  ```
                  + Settings 정보는 아래와 같이 MyBatis 설정을 위해 활용 된다. 아래 예시에 기술되어 있는 value 값은 default 값이며, 설정이 생략되는 경우에는 자동으로 default 값을 가진다.
                  ```
                  <settings>
                     <setting name="cacheEnabled" value="true"/>
                     <setting name="lazyLoadingEnabled" value="false"/>
                     <setting name="multipleResultSetsEnabled" value="true"/>
                     <setting name="useColumnLabel" value="true"/>
                     <setting name="useGeneratedKeys" value="false"/>
                     <setting name="autoMappingBehavior" value="PARTIAL"/>
                     <setting name="autoMappingUnknownColumnBehavior" value="NONE"/>
                     <setting name="defaultExecutorType" value="SIMPLE"/>
                     <setting name="defaultStatementTimeout" value="null"/>
                     <setting name="defaultFetchSize" value="null"/>
                     <setting name="safeRowBoundsEnabled" value="false"/>
                     <setting name="mapUnderscoreToCamelCase" value="false"/>
                     <setting name="localCacheScope" value="SESSION"/>
                     <setting name="jdbcTypeForNull" value="OTHER"/>
                     <setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/>
                    </settings>
                   ```
               4. Spring 설정
                   + Spring과 MyBatis 연동을 위한 설정으로 sqlSession 객체를 생성하고 관리하며, DB연결에 필요한 DataSource, Mapper configuration, Mapper configuration 파일의 위치를 설정한다. Mapper location을 일괄로 지정할 수도 있다. 이 경우 Mapper configuration의 mapper 위치와 중복지정할 수 없다.
                   ```
                   <?xml version="1.0" encoding="UTF-8"?>
                   <beans xmlns=http://www.springframework.org/schema/beans
                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                           xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans-4.0.xsd">
                   
                   <bean id="sqlSession" class="org.mybatis.spring.SqlSessionFactoryBean">
                       <property name="dataSource" ref="dataSource" />
                       <property name="configLocation"
                           value="classpath:/META-INF/sqlmap/sql-mybatis/config.xml"/>
                           
                       <property name="mapperLocations"
                           value="classpath:/META-INF/sqlmap/mappers/lab-*.xml"/>
                   </bean>
                   </beans>
                   ```
                   + Annotation 방식의 DI 설정을 위하여 component scan 설정을 하였고, DB properties를 파일에서 읽을 수 있도록 properties를 지정하였다.
                   ```
                   <?xml version="1.0" encoding="UTF-8"?>
                   <beans xmlns=http://www.springframework.org/schema/beans
                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                       xmlns:context="http://www.springframework.org/schema/context"
                       xsi:schemaLocation="http://www.springframework.org/schema/beans
                       http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
                       http://www.springframework.org/schema/context
                       http://www.springframework.org/schema/context/spring-context-4.0.xsd">
                       
                       <context:property-placeholder
                           location="classpath:/META-INF/spring/jdbc.properties"/>
                       <context:component-scan base-package="lab"/>                       
                   </beans>
                   ```
                   + DB연결을 하기 위한 DBCP설정과 jdbc properties 설정
                   ```
                   <?xml version="1.0" encoding="UTF-8"?>
                   <beans xmlns=http://www.springframework.org/schema/beans
                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                       xmlns:jdbc="http://www.springframework.org/schema/jdbc"
                       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
                           http://www.springframework.org/schema/jdbc
                           http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd">
                       <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destory-method="close">
                           <property name="driverClassName" value="{driver}"/>
                           <property name="url" value="{durl}"/>
                           <property name="username" value="{user}" />
                           <property name="password" value="{password}"/>
                       </bean>
                   </beans>
                   ```     
                   + DBCP 설정 예시
                   + DBCP 설정에 변수 처리 되어 있는 값은 아래의 값으로 치환되어 실행된다.
                   + 만약 DB를 다르게 설정하였거나 별도 DB를 활용하는 경우 설정을 변경하여 실행
                   ```
                   driver=com.mysql.jdbc.Driver
                   dburl=jdbc:mysql://127.0.0.1:3306/com
                   user=com
                   password=com01
                   ```
                   + DB 연결 속성
               5. DAO 작성
                   + EgovAbstractMapper 클래스를 상속받아 DAO 클래스를 작성
                   + EgovAbstractMapper 클래스는 SqlSessionDaosupport의 하위클래스 SqlSession 설정과 메소드 호출의 편리함을 제공
                   + EgovAbstractMapper를 쓰지 않으면, insert, update, delete, select 등을 실행 할 때 앞에 "getSqlSession().insert()"의 형태로 앞에 "getSqlSession().insert()"의 형태로 써주어야 되기 때문에 불편하다.
                   
                   ```
                   @Repository("customerDAO")
                   public class CustomerDAO extends EgovAbstractMapper{
                       public void insertCustomer(CustomerVO vo){
                           insert("customer.insertCustomer",vo);
                       }
                       
                       public List<CustomerVO> selectCustomerList(CustomerVO vo){
                           return selectList("customer.selectCustomerList",vo);
                       }
                   }
                   ```
                   + Parameter 및 Result Object로 활용되는 CustomerVO는 다음과 같이 id, name, address 세 개의 멤버변수를 가지는 클래스이다.
                   ```
                   public class CustomerVO{
                       String id;
                       String name;
                       String address;
                   }
                   ```
                   
               6) Service 및 Java 어플리케이션 생성
                   + Controller, JUnit, Java 어플리케이션에서 실행시킬 수 잇도록 서비스를 작성.
                   + 일반적으로 트랜잭션 및 비즈니스 로직 처리를 위한 서비스를 정의, 실행시키는 것이 일반적이며, DAO를 바로 호출하지 않는다.
                   + 현재는 비즈니스 로직이 없기 때문에 괜히 한 계층을 더 호출하는 것 같아 불필요해 보일 수 있어도, 실제 복잡한 업무를 구현하는 환경에서 유연한 처리와 모듈의 재사용성을 높이기 위해서 필요하다.
                   ```
                   @Service("customerService")
                   public class CustomerServiceImpl implements CustomerService {
                       @Resource(name = "customerDAO")
                       public CustomserDAO customerDAO;
                       
                               public void insertCustomer(CustomerVO customerVO) throws Exception {
                                   customerDAO.insertCustomer(customerVO);
                               }
                               
                               public List<CustomerVO> selectCustomerList(CustomerVO customerVO) throws Exception {
                                   return customerDAO.selectCustomerList(customerVO);
                               }
                       }
                   }
                   ```
                   + 구현된 DAO와 Service를 테스트하기 위해 값을 INSERT하고 SELECT하는 JAVA 어플리케이션 구현하여 실행
                   ```
                   public class CustomerApp {
                       public static void main(String[] args) throws Exception {
                           String configLocation = "classpath*:META_INF/spring/context-*.xml";
                           ApplicationContext context = new ClassPathXmlApplicationContext(configLocation);
                           
                           CustomerService customer
                               = (CustomerService)context.getBean("customerService");
                               
                           vo.id = "1";
                           vo.name = "KIM";
                           vo.address = "SEOUL";
                           customer.insertCustomer(vo);
                           
                           vo.id = "2";
                           vo.name = "LEE";
                           vo.address = "PUSAN";
                           customer.insertCustomer(vo);
                           
                           List<CustomerVO> resultList = customer.selectCustomerList(vo);
                           int num = resultList.size();
                           for (int i=0; i<num; i++){
                               CustomerVO resultvo = resultList.get(i);
                               System.out.println("id="+resultvo.id);
                               System.out.println("name="+resultvo.name);
                               System.out.println("address="+resultvo.address);
                           }
                       }
                  }
                  ```
                  + 구현된 JAVA 어플리케이션의 결과
                  ![image-3.png](attachment:image-3.png)
                  
                  + 앞에서 살펴보았던 Java SQL을 활용하여 프로그래밍 하는 것과 MyBatis를 활용하는 것을 비교해보면, DB연결, SQL문 준비, 실행 후에 ResultSet처리, 리소스 반환 등 개발자가 처리해야 될 것이 많고, 프로그램이 늘어날수록 비슷한 형태의 코드가 계속 늘어나게 되고, 반복적으로 개발하게 된다. MyBatis의 경우는 SQL들은 모두 설정파일로 들어가게 되고, 실행시에는 mapper에 정의된 SQL id와 parameter object를 전달하여 실행하면 되기 때문에 간단하게 구현과 실행이 가능하며, 많은 업무를 처리 할 때도 소스코드 수가 아주 많아지지 않고, 코드들이 정형화 되어 유지보수가 편리하다. 불필요하고 반복적인 소스코드를 개발할 필요가 없이 SQL을 정의해주고, 실행만 시켜주면 다른 부분들은 MyBatis가 처리하게 된다.
                  ![image-4.png](attachment:image-4.png)
                  + 앞의 예제에서 SQL문은 XML에 정적으로 위치하고 있는데, 개발을 하다 보면 조건에 따라 SQL문이 바뀌어야 되는 경우가 있다. 특히 검색 같은 경우 검색 조건에 따라서 SQL 문이 바뀌어야 된다. 이러한 처리를 가능하도록 하기 위해 MyBatis에서 Dynamic SQL을 지원한다. If는 가장 많이 사용되는 요소로 조건 결과에 따라서 해당 SQL을 포함하거나 미포함 할 수 있도록 조정할 수 있다. 아래 예제에서는 empNo가 null이 아니거나, empName이 null이 아닌 경우 where 절에 조건이 포함하게 된다. 이 때 trim을 활용하면, 반복되는 문자를 자동으로 제거할 수 잇다. Where절 다음 앞에 나오는 AND, OR 등의 문자를 제거할 수 있으며, 조건을 모두 만족하지 않으면 where절도 포함되지 않는다. 이외에도 foreach, choose 등을 활용하여 Dynamic SQL을 생성할 수 있다.
                  ```
                  <select id="selectEmpList" parameterType="empVO" resultType="empVO">
                      select EMP_NO as empNo, EMP_NAME as empName, EMP_NAME as empName from EMP
                      <trim prefix = "WHERE" prefixOverrides = "AND|OR">
                          <if test="empNo !+ null">
                              EMP_NO = #{empNo}
                          </if>
                          <if test="empName != null">
                              AND EMP_NAME LIKE '%' || #{empName} || '%'
                          </if>
                      </trim>
                  </select>
                  ```
              5. Transaction 처리
                  + Transaction 처리는 DB 데이터의 정합성을 위해서 반드시 필요한 개념.
                  + ex) 쇼핑몰에서 고객이 주문한 상품을 배송하려는 상황에서, 시스템에서 진행 단계를 배송 단계로 수정하는 처리와 신규로 배송정보를 입력하는 두 가지의 데이터 처리가 있다고 가정해보자. 만약 처리 단계를 수정하는 단계에서 에러가 발생되었는 데 배송정보가 입력이 되었다면, 배송 단계가 아닌 데도 배송처리가 된다. 올바른 결과를 가지려면 두 가지 처리가 모두 성공해야만 전체적으로 처리가 되는 것이고, 두 개 중에 하나라도 오류가 발생되면 이미 성공한 것도 실패한 것으로 처리되어 아무것도 수행하지 않은 이전의 상태로 되돌려야 한다. 이렇게 데이터 정합성을 관리하는 것을 transaction 처리라고 한다. 하나의 transaction 안에 포함된 DB처리가 모두 성공하게 되면 commit이 되고, 하나라도 실패하면 원래의 상태로 돌아가게 되며 이를 rollback이라고 한다.
                  ![image-5.png](attachment:image-5.png)
                  + Transaction을 활용하기 위해서는 먼저 서비스를 제공할 transaction manager를 결정해야한다. Transaction Manager는 두 가지가 있는 데, Spring에서 제공하는 datasource 기반의 transaction manager를 사용하여 관리하는 방법과 WAS에서 제공하는 JTA(Java Transaction API)를 활용하는 방법이 있다. Datasource를 활용하는 방법은 다음과 같이 transaction manager bean을 생성하면 된다.
                  ```
                  <bean id="transactionManager"
                      class = "org.springframework.jdbc.datasource.DataSourceTansactionManager">
                      <property name="dataSource" ref="dataSource"/>
                  </bean>
                  ```
                  + JTA를 활용하는 방법은 WAS에서 transaction manager를 설정하고 이를 JNDI로 연결하여 활용하는 방식으로 앞에서 설명했던 connection pool을 활용하는 방법과 비슷하다. 웹 로직에서 JTA를 활용하여 transaction manager를 설정하는 예시는 다음과 같으며, jndi-name이나 provider url은 설정한 환경에 맞추어 변경을 해야 한다. Datasource transaction 서비스와 달리 별도 transaction manager bean을 정의하지 않아도 된다. 상용 WAS를 활용하는 경우 WAS에서 제공하는 JTA를 활용하는 것이 좋다.
                  ```
                  <tx:jta-transaction-manager />
                  <jee:jndi-lookup id="dataSource" jndi-name="dbmsXADS" resource-ref="true">
                      <jee:environment>
                          java.naming.factory.initial=weblogic.jndi.WLInitialContextFactory
                          java.naming.provider.url=t3://was:7002
                      </jee:environment>
                  </jee:jndi-lookup>
                  ```
                  + Transaction manager가 설정되면 소스코드에서 transaction을 처리하는 방식을 결정해야 한다.
                  + 첫번째는 Annotation을 활용하는 방법, 두번째는 AOP를 활용하는 방법, 세번째는 직접 코드에서 transaction API를 호출하는 방법이 있다.
                  + 세가지 방법 중에 어느 것을 선택하여도 결과는 같으며, 활용하기 편리한 것으로 결정하면 된다.
                  + AOP를 활용하면 XML로 advice와 point cut 설정만 하면 소스코드에 아무런 설정이 없어도 transaction이 적용되어 편리하다.
                  + Transaction 설정 테스트를 위해서 추가로 employee테이블을 생성한 후에 동일한 값("1", "KIM", "SEOUL")을 INSERT한다.
                  + customer 테이블의 값에서 "SEOUL"을 "BUSAN"으로 수정하고, employee는 수정시에 컬럼 수를 초과로 값을 입력하여 고의로 에러를 유발한다.
                  + 트랙잭션 처리를 한 상태에서 결과를 출력하면 rollback 처리가 되어 수정 이전의 값인 "SEOUL"을 유지하게 된다. 트랜잭션 처리를 하지 않고 결과를 출력하면 수정된 값이 그대로 유지되어 "PUSAN"이 출력되게 된다.
                  ![image-6.png](attachment:image-6.png)
                  ![image-7.png](attachment:image-7.png)
                  ![image-8.png](attachment:image-8.png)
                  ![image-9.png](attachment:image-9.png)
                  ![image-10.png](attachment:image-10.png)





















































