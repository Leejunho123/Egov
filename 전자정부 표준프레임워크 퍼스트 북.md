# 전자정부 표준프레임워크 퍼스트 북 
### https://www.egovframe.go.kr/home/ntt/nttRead.do?menuNo=65&bbsId=4&nttId=1449

1. 전자정부 표준프레임워크
    + 공공사업에 적용되는 SW 프레임워크의 표준을 정립
    + 응용 SW 표준화
    + 품질 및 재사용성을 높일 수 있는 기반 제공
    
    1. SW 프레임워크 등장배경
        - 메인프레임 시대부터, Client/Server, 시대의 전환인 WEB의 등장 모바일/클라우드 시대까지 변화해오면서, 이제는 누구나 소프트웨어를 사용하고, 사용해야만 생활할 수 있는 시대가 되었다. 최근 들어서는 twitter, Facebook 등 소셜미디어의 등장으로 거대한 데이터들이 날마다 생산. 이러한 데이터를 분석, 활용/처리 하는 데 IT 업계의 대표적인 이슈
        - 가장 중요시 되던 부분 : 자동화, 재사용
        - 기술 발전으로 실시간 처리와 일괄 처리로 구분.
        - 소프트웨어 규모의 대형화 및 복잡화 -> 개발 비용 증대
        - 일관되지 않은 개발 방식 -> 유지보수성 악화
        - 새로운 기술 교육 및 훈련 부족 -> SW 개발 및 운영에 많은 문제점 발생.
        - 이 원인들로 다양한 발전이 있었음

        1. 소스 재사용
            - 초보적인 재사용 방식으로 과거 코드를 복사해서 사용
        2. 재사용 메소드
            - 복사/붙이기 방식과 동일한 코드가 여러 클래스에서 나오는 것을 지양
            - 라이브러리로 만들어 재사용하는 방식
        3. 재사용 객체
            - 기존의 재사용방식 - 소스 재사용, 재사용 메소드 - 들은 자바뿐만 아니라 다른 언어를 사용할 때도 가능한 방식이나, 확장이 쉽지 않은 방식이었다면, 자바 언어에서는 클래스는 설계하고 상속, 확장하는 방식으로 재사용을 진행.
        4. 디자인패턴
            - 클래스의 재사용 방식이 객체의 수직적인 재사용 방식, 디자인 패턴은 상황적인 문제를 해결해주는 재사용 방식.
            - 메커니즘의 재사용으로 진행
        5. SW 프레임워크
            - 디자인 패턴은 상황에 대한 해결이 가능. 시스템 전체에 대해서는 직접 패턴을 적용하여 문제를 해결.
            - 이러한 문제점을 해결하기 위해 전체 시스템적 관점에서 표준화된 디자인 패턴을 적용한 설계 및 구현체가 SW 프레임워크
    2. SW 프레임워크 정의
        - SW 프레임워크의 사전적 의미 : 무엇을 이루는 뼈대 혹은 기반 구조.
        - 개발을 도와주는 부분부터 사상에 이르기까지 다양한 범위로 논의.
        - 소프트웨어 시스템에 대한 라이브러리 또는 클래스의 재사용 세트
        - 소프트웨어의 특정 클래스에 대한 재사용 가능한 디자인을 구성하는 클래스틀 협력의 집합 - GoF 패턴
        - 종합 정의
            - 일련의 문제 해결을 위한 추상화된 디자인을 구현한 클래스들의 집합으로 클래스 보다는 큰 규모의 재사용을 지원
            - 구체적이며 확장 가능한 기반 코드, 설계자가 의도하는 아키텍쳐와 디자인 패턴 집합
            - 실전에서 얻은 최적화 개발 경험을 반영한 재사용 가능한 API집합
            - 라이브러리와 달리 어플리케이션의 틀과 구조를 결정, 그 위에 개발된 개발자의 코드를 제어하는 반 제품 성격의 소프트웨어
            
        - 장점
            - 개발용이성
            - 시스템 복잡도의 감소
            - 이식성
            - 품질보증
            - 운영 용이성
            - 개발코드의 최소화
            - 변경용이성
            - 설계와 코드의 재사용성
            
    3. 표준프레임워크 개요
        - 표준프레임워크 전 전자정부 지원사업 시에 대기업의 SW 프레임워크가 도입 활용.
        - 그로 인한 문제점 : 폐쇄적 정책. 자사 SW 프레임워크를 공개, 판매 하지 않아 상호호환성을 보장하기가 어려움
        - 따라서 연속 사업 혹은 유지보수사업의 사업자 변경을 원칙적으로 어렵게 한다는 문제가 있었다.
        - 이미 특정 SW 프레임워크를 활용하여 구축된 소스코드를 다른 SW 프레임워크로 변경이 불가능하기 때문에 SW 프레임워크의 적용은 불가피하게 소스 코드의 종속성 문제를 가지게 됨.
        - 결국 공동 SW 프레임워크 필요성
        - 표준프레임워크는 실행, 개발, 관리, 운영 등 4개의 환경 과 모바일 표준프레임워크, 공통컴포넌트로 구성.
        - 참조프레임워크로 대표적인 오픈소스 SW프레임워크인 스프링 프레임워크 채택
        - OSS를 적용/ 활용하여 구성
        - 전자정부 서비스의 품질향상, 정보화 투자 효율성 향상을 달성
        - 대,중소기업이 동일한 개발기반 위에서 공정 경쟁이 가능하게 된다.
        - 표준프레임워크는 기존 다양항 플랫폼 환경을 대체하기 위한 표준은 아니며, java 기반의 정보시스템 구축에 활용할 수 있는 개발,운영 표준 환경을 제공하기 위한 것.
        - 공공 정보화 사업에 많이 활용되는 인프라 환경과의 호환성 보장
        - 광범위한 보급-확산을 위해 소스 뿐만 아니라 분석-설계 산출물도 함께 공개
        - 다수가 만족하는 표준이 될 수 있도록, 개발 과정에서 다양한 전문가로 구성된 협의회 의견을 청취-반영
        

    4. 표준프레임워크 활용 고려 사항
        1. 자바 기반의 웹 응용 시스템(WAS가 존재하는 경우)
        2. (2.7 기준) JavaEE(J2EE) 5 혹은 JDK1.5 이상의 환경 (단, 개발환경 2.7 이상에서는 JDK 1.6이상 필요)...
        3. 신규 개발시스템으로써, 기존 시스템과 물리적 혹은 논리적으로 구분되는 경우
        
        + 표준프레임워크는 표준으로써 목적을 만족하기 위하여 아래의 규칙을 준수하여 적용
            - 실행환경은 원칙적으로 변경 없이 활용해야 함
            - 개발환경은 기능의 변경과 추가에 제약사항 없음
            - 공통컴포넌트는 변경 가능하나, 표준프레임워크 아키텍쳐 준수 필요
            

2. 개발환경 구성하기
    1. 개발환경 구성
        - 구현도구, 테스트도구, 형상-변경관리 도구, 배포도구로 구성
            - 구현도구 : 프로그램 개발, 컴파일, 디버그 등 개발자 개별 환경 제공
            - 테스트도구 : 개발자가 단위테스트를 수행하고 결과를 리포팅
            - 형상-변경관리 도구 : 개발자가 작성한 소스코드를 통합하여 버전관리 수행
            - 배포도구 : 형상관리의 소스코드를 통합 빌드하고 개발 서버 등에 배포
        - 개발환경 : 개발자 PC에서 작업이 진행되는 개발자 개발환경과 개발서버 및 운영서버에서 진행되는 서버개발환경으로 구성
        - 개발자 : 개발 환경을 활용 소스코드를 제작, 컴파일 및 테스트를 구행하고 실행 가능한 형태로 빌드
        - 개발자 개인 별 소스코드를 수정하여 commit하거나 update하는 형태로 공동작업 형태 개발.
        - 배포도구는 통합저장된 소스코드를 불러와서 통합 빌드한다.
        - 웹 어플리케이션 서버 등에서 실행이 가능한 형태로 구조화하여 배포
        - 주요 오픈소스
            - 구현도구 : Eclipse, PMD, Maven
            - 테스트도구 : JUnit, EasyMock, DbUnit, EclEmma
            - 형상-변경관리도구 : Subversion, jTrac
            - 배포도구 : Hudson, Nexus, Maven
                - Eclipse : 자바 소스코드를 편집, 컴파일, 테스트, 실행이 가능하도록 지원하는 대표적인 개발도구
                - PMD : Eclipse 플러그인. 룰셋 기반으로 소스코드 오류 등을 검사하여 품질을 높이도록 한다.
                - Maven : 소스코드 컴파일에 필요한 라이브러리를 관리하고 컴파일, 테스트, 빌드 등 작업을 수행
                - JUnit : 단위테스트 코드를 작성하여 테스트하도록 지원한다.
                - EasyMock : 웹 어플리케이션을 실행하지 않고도 테스트가 가능하도록 시뮬레이션 환경을 지원
                - DBUnit : DB 테스트 데이터를 생성 결과가 미리 입력된 결과값과 같은지 비교할 수 있도록 환경 지원
                - EclEmma : 실제 소스 코드에서 단위테스트로 수행된 부분이 어느 정도인지 퍼센트 형태로 정보를 알려주는 coverage 테스트
                - Subversion : 형상관리도구. 소스 통합 버전관리
                - jTrac : 변경관리 이력 등을 추적 가능
                - Hudson : 지속적 테스트와 통합을 지원하는 CI 도구
                - Nexus : Maven 라이브러리 3rd Party로 제공시에 활용
   
            

    2. 개발환경 설치 및 구성
        - 프레임워크 홈페이지에서 제공하는 교육교재를 활용하는 방법 : 모두 구성. 활용 가능
        - 표준프레임워크에서 개발환경을 내려 받고 Tomcat,JDK 등 필요한 설정을 한다.
        - 기존에 활용하던 Eclipse에 표준프레임워크 플러그인을 설치하여 활용하는 방법
        1. 교육실습교재 사용
            - 교육자료 다운.
            - 표준프레임워크을 처음 사용하는 사용자나 자바에 익숙하지 않은 개발자들은 처음에는 이 방법을 활용하여 사용하는 것을 권장
            - 필요한 소프트웨어 및 설정이 되어 있어 바로 활용 가능
        2. 개발환경 구성
            - Tomcat 등등 다 설치해주고 연동까지 해줘야 한다.
        3. 기존 Eclipse에 플러그 인 설치
            - 개발은 가능. egovFrame전용 도구는 활용 불가.

3. 개발자 개발환경 활용
    1. 구현도구 활용
        - Eclipse Java EE를 기반으로 표준 프레임워크 플러그인이 설치되어 있다.
        - Eclipse 기본화면은 메뉴바, 툴바, 퍼스펙티브바, 4개의 뷰 영역으로 구성
        - 4개의 뷰를 포함하는 전체 영역을 퍼스펙티브, Eclipse Window 전체를 워크벤치라 부름
        - 구현도구는 통합메뉴, 퍼스펙티브, 뷰, 에디터 등을 제공
        - eGovFrame 퍼스펙티브를 선택하면, 메뉴에 eGovFrame 통합 메뉴가 나타나게 된다.
        - 통합메뉴는 유형별 프로젝트 생성, 각종 다이어그램 작성, SQLMap 편집, 공통컴포넌트 생성 등 기능을 제공.
    2. Maven 활용
        1. 라이브러리 의존성 관리
            - 기존에 개발된 수많은 라이브러리를 활용하여 필요한 기능을 쉽게 확장할 수 있다는 장점
            - 종속성 및 버전관리가 어려운 문제
            - 특징 라이브러리를 활용하기 위해서는 참조하고 잇는 다른 라이브러리도 함께 활용이 되어야 한다.
            - A라는 라이브러리가 B와 C라이브러리 기능을 활용하고 있다면 A만 가지고는 활용이 불가능. B,C를 함께 참조
            - 버전 문제
            - 이 모든 라이브러리의 Build Path를 개별적으로 설정은 불가능
            - Maven은 이러한 라이브러리 관리 문제를 해결하기 위해 의존성 설정을 활용하여 라이브러리를 관리
            - 실제 pom파일 dependency가 의존성 설정인데 모든 jar가 들어가 있지 않다. 이는 특정 라이브러리를 다운받을 때 그 라이브러리에도 pom 파일이 존재하여 그 안의 버전에 따른 다른 라이브러리 또한 다운받기 때문. 이는 Maven local repository에 저장되어 있다.
            - pom dependency 예제
                ```
                <dependency>
                 <groupId>egovframework.rte</groupId>  라이브러리 식별 namespace
                 <artifactId>egovframework.rte.ptl.mvc</artifactId>  라이브러리 명
                 <version>{egovframework.rte.version}</version>  버전정보
                 <exclusions>  옵션이며, 충돌 등의 이유로 특정 라이브러리 의존성 제거
                 <exclusion>
                 <artifactId>commons-logging</artifactId>
                 <groupId>commons-logging</groupId>
                 </exclusion>
                 </exclusions>
                </dependency>
                ```
            - 처음 Maven 실행 시 Local Repository에 라이브러리가 없다면 pom.xml의 repository에 기술된 Remote Repository로부터 라이브러리를 다운받게 된다. 사용자가 Nexus 등을 활용하여 개별적 3rd Party 라이브러리를 구성할 수도 있다. 인터넷이 차단된 폐쇄망에서는 필수적으로 별도 Repository를 구성해야함
        2. 빌드 관리
            - Maven에서는 디렉터리 구조를 정규화. 복잡한 설정 없이 컴파일, 패키징 등을 수행가능.
            - 실제 소스파일, 테스트 소스 파일로 구성. resources 디렉터리에는 jar나 war로 패키징 될 때 함께 배포되어야 할 설정파일 등의 리소스가 위치
            - 웹 프로젝트의 경우 webapp 밑에 MVC 설정과 웹 리소스 (HTML, 자바스크립트, 이미지 등)가 위치.
        3. Maven 설정
            - pom.xml : 프로젝트의 정보, 의존성, 빌드 세팅(플러그인) 정보를 포함하고 있다. Maven 프로젝트는 빌드 되어 로컬 또는 원격 Repository에 배포될 수 있기 때문에 자체적으로 GroupId, Artifact Id, 버전 정보를 가짐.
            - 라이브러리 관리를 위한 의존성 관리
            - 컴파일, 패키징 뿐만 아니라 테스트 결과 리포트, java doc 생성과 같은 작업들을 플러그인 설정을 통해서 수행 가능.
            - Maven 은 빌드 작업시에 플러그인을 활용하여 생명주기 단계별로 플러그인을 바인딩하여 작업을 처리.
            - 플러그인의 설정은 pom.xml의 pluginManagement 에 기술.
            - 표준프레임워크에서 설정하여 제공하고 있는 주요 Maven 플러그인 정보
                - complie : maven-compiler-plugin : 소스코드 컴파일
                - test : maven-test-plugin, maven-surefire-plugin : 단위테스트 실행과 리포트 생성
                - package : maven-jar-plugin, maven-war-plugin : 압축파일 생성
                - emma : maven-emma-plugin : Code coverage report 생성
            - maven build 시 모든 필요한 소스들 다운로드
            - maven install 시 compile, test, package, install의 순서로 실행
                - compile : resources 플러그인이 실행, 소스 코드가 copy, compiler 플러그인이 동작하여 컴파일을 수행
                - test : test 플러그인이 실행, 단위테스트 수행, surefire 플러그인을 통해 테스트 결과 리포트 생성
                - package : war 플러그인이 동작되어 war 배포파일 생성.
                - install 단계에서 로컬 repository로 배포.

4. 서버 개발환경 활용
    1. 형상관리 도구 활용
        1. Subversion 개요 및 설치
            + 형상관리 도구는 팀프로젝트 수행시에 개인 개발자들이 작성한 소스코드를 하나의 프로젝트로 통합.
            + 변경된 내용을 버전관리하여 변경 히스토리를 관리하고 필요한 경우 이전 버전으로 변경할 수 있도록 기능을 지원.
            + Subversion은 파일 뿐 아니라 디렉터리도 버전관리를 지원. 변경관리를 변화된 부분만 관리하여 성능이 우수.
            + 윈도우 환경의 서버 VisualSVN을 활용하면 SubVersion을 쉽게 설치할 수 있음.
        2. Revisions
            + 저장소에 저장된 각각의 파일 버전.
            + Commit 시에 일정한 규칙에 의해서 숫자가 증가.
            + Subversion은 변경 발생 시에 전체 단위로 Revision을 갱신하여 관리.
            + 개발 파일 단위로 Revision을 관리하게 되면 전체적으로 소스코드에 변경이 일어난 순서 정보를 알기 어렵게 됨.
        3. Eclipse와 연동
            + Subversion을 활용하기 위해 제일 먼저 해야 하는 일은 프로젝트 최초 commit하는 것.
            + 최초 commit이 되어 Subversion repoistory에 저장.
            + 다른 개발자들이 자신의 workspace로 내려 받아 활용 가능 이를 check out.
            + 그 후에는 commit, update
            + 종종 충돌 가능. 다시 Commit or Update 하면 됨 (Override and Commit, Override and Update)

    2. 배포 도구 활용
        1. CI 개요 및 설치
            - 전통적으로 SW 개발은 분석, 설계, 개발, 테스트의 순서로 진행
            - 프로젝트의 위험 요소는 에러, 미개발, 요구사항 미 충족 등의 결함이 프로젝트 후반 특히 오픈 직전에 발견
            - 이러한 문제를 해결하기 위해 소스코드 통합과 테스트를 상시적으로 수행하는 개념이 CI이다.
            - 많은 개발자로 구성된 팀이 작업한 것을 짧은 주기로 통합 및 테스트를 수행하는 소프트웨어 개발 방식이다.
            - commit -> 형상관리 서버에서 통합 -> check out -> Maven 등 도구 활용하여 테스트 및 빌드.
            - 주로 Maven package를 수행하여 테스트 및 배포파일 생성. 개발서버 배포
            - 라이브러리 : Maven deploy를 실행하여 Nexus 등의 원격 Repository로 배포할 수 있다.
            - CI 서버로는 Hudson이 많이 활용되었으나 Sun이 Oracle로 흡수 합병에 따라 기존 Hudson 오픈소스 프로젝트에 변경이 생기면서 Jenkins 프로젝트가 시작되었다.
            - Hudson도 Eclipse에서 오픈소스 프로젝트로 개발이 진행 중에 있으나 Jenkins보다 업데이트 등이 활발하지 못한 상태.
            - 두 개의 CI서버는 거의 동일한 기능을 가지고 있기 때문에 굳이 구별할 필요는 없지만, 사용성 및 향후 발전 측면에서는 Jenkins가 더 유리한 상태이므로 Jenkins 기준으로 설명.
            - war파일 Tomcat 등의 WAS 의 webapp 밑에 압축을 풀어 주는 것으로 설치가 완료.
            - Hudson의 경우도 마찬가지로 설치가능.
            - Jenkins의 경우 WAS까지 패키징하여 윈도우, 맥 등의 실행파일 형태로 설치할 수 있도록 지원하고 있다.
            - 이 경우 별도의 WAS의 설치가 불필요하여 편리하지만 OS에서 자동 실행되는 서비스로 등록되기 때문에 개발 및 테스트 용도로는 관리가 어려울 수 있다.
           
            
            

5. 실행환경 소개
    1. 실행환경 구성
        + 실행환경은 화면처리, 업무처리, 데이터처리, 연계, 공통기반, 배치처리 Layer로 구성
            + 화면처리 Layer : 사용자 인터페이스 및 화면 구현에 필요한 기능과 구조 제공
            + 업무처리 Layer : 예외 처리 및 업무흐름 처리 기능을 제공
            + 데이터처리 Layer : 개발자가 작성한 소스코드를 통합하여 버전관리 수행
            + 연계 Layer : SOAP기반 웹 서비스 기능 제공
            + 공통기반 Layer : 재사용 컴포넌트, 로그 등 개발에 필수적인 기능 제공
            + 배치처리 Layer : 일괄처리를 위한 설정 및 실행 기능 제공
            
        + 실행환경 Layer별로 하위 서비스를 제공. 화면처리 Layer의 경우 기본 패턴인 MVC이외에 국제화, Ajax, 국제화 등 기능을 제공.
        + 데이터처리 Layer 의 경우에는 DB 접속을 위한 DataSource
        + SQL을 XML 설정파일에서 관리 할 수 있도록 지원하는 Data Access
        + 자바코드로 SQL을 대신할 수 있는 ORM 서비스
        + 공통기반 레이어에는 표준 패턴을 제공하는 IOC,AOP와 Logging 등 서비스를 제공
        ![image](https://user-images.githubusercontent.com/73324807/114120956-7ecc6c80-9928-11eb-9710-6d952c20b5e7.png)
        + 표준프레임워크 실행환경에서 서비스 별로 채택 활용하고 있는 대표적은 오픈소스는 다음과 같다.
        ![image](https://user-images.githubusercontent.com/73324807/114120982-88ee6b00-9928-11eb-8ab5-65a70c463d48.png)
        + 표준프레임워크 주요 패턴과 기능은 Spring 프레임워크 기반으로 구성.
        + Spring 프레임워크 : Java 웹 어플리케이션 개발을 쉽게 해주는 오픈소스 SW 프레임워크이다.
        + 인터페이스와 구현으로 구성된 자바 객체는 Spring 컨테이너에 빈 형태로 등록되어 활용된다.
        + Spring 프레임워크는 IoC 컨테이너로 구성되는 CORE, DB를 지원하는 DAO, JPA 등 ORM 메시징 등 Enterprise 환경을 지원하는 JEE, 웹 환경을 지원하는 WEB의 패키지로 구성된다.
        ![image](https://user-images.githubusercontent.com/73324807/114120834-4036b200-9928-11eb-83f9-a6b03da297ae.png)
        ![image](https://user-images.githubusercontent.com/73324807/114120909-68261580-9928-11eb-8667-69019426562d.png)

6. DI
    + 자바프로그래밍 시 구현된 기능을 다른 소스코드에서 활용할 때 설정되어 있는 소스코드 간의 종속성 부분은 재사용에 큰 어려움을 주게 된다.
    + 이러한 문제를 해결하기 위해 DI를 활용하여 소스코드간에 직접적으로 종속성을 가지지 않고, 참조 정보를 XML 설정파일이나 annotation을 활용하도록 한다. -> 소스코드를 직접 고치지 않고 소스코드를 참조할 수 있도록 지원
    1. 자바 인터페이스
        + 자바 인터페이스는 클래스들이 구현해야 하는 동작을 지정하는 데 사용되는 추상형, 클래스들이 지켜야 하는 형식을 정의
        + 인터페이스는 클래스에서 외부로 노출되어 활용되는 변수나 메소드 정보를 제공하여 다른 클래스에서 쉽게 참조할 수 있도록 한다.
        + 그리고, 현재의 클래스를 다른 클래스로 대체하기 위해 반드시 구현이 필요한 메소드 정보를 제공한다.
        + 인터페이스에 있는 메소드만 구현이 되면 클래스를 다른 클래스로 교체하여 사용할 수 있다.
        + 일반적으로 컴포넌트를 구성할 때 인터페이스와 클래스를 묶어서 구성하게 된다.
        + 컴포넌트는 특정한 기능을 다른 기능으로 쉽게 대처할 수 있도록 구성이 되어야하기 때문에 인터페이스 정보는 필수적이다.
        + 외부의 다른 클래스에서 활용가능한 메소드는 인터페이스에 기술되어 있기 때문에 인터페이스에 있는 정보만 참조하면 된다.
        + 인터페이스를 활용하여 클래스 정보의 추상화, 캡슐화가 가능하다.
        + 그림에서 NameServiceImpl 클래스에 많은 메소드가 있지만 NameService 인터페이스를 Type으로 활용하고 클래스 인스턴스를 생성하게 되면 다른 메소드들은 참조할 수 없고, 인터페이스에 기술된 getName()만 참조가 가능하다.
        + 자바에서 클래스 인스턴스를 생성할 때 별도 인터페이스를 생성하지 않고 클래스 자체를 Type으로 생성할 수 있으나, 인터페이스를 활용하는 경우 다른 클래스에서 참조 가능한 메소드만 표현하고, 다른 메소드들은 노출시키지 않아도 되기 때문에 활용이 편리하다.
        
        ![image](https://user-images.githubusercontent.com/73324807/114121018-960b5a00-9928-11eb-946d-e1d63b33a443.png)

        
        + 인터페이스는 동작에 관련된 처리 로직 등의 코드가 포함되어 있지 않고, 구현을 위한 메소드 명, 입출력 Type 등 형식만 정의한다.
        ![image](https://user-images.githubusercontent.com/73324807/114135629-771ac100-9944-11eb-9bc0-aea918e7ead5.png)

        
        + 앞의 설명에서 String 값의 id를 입력 변수로 가지고, 결과값을 String 값으로 반환하는 getName() 메소드를 가지는 NameService 인터페이스는 다음과 같이 작성된다.
        ![image](https://user-images.githubusercontent.com/73324807/114135646-7eda6580-9944-11eb-9ee0-35470b51d7f6.png)

        
        + 클래스는 인터페이스 정보를 참조하여 정의되어 있는 메소드는 반드시 구현해야 한다. 만약 구현하지 않으면 에러가 발생된다. NameService 인터페이스를 참조하여 구현한 NameServiceImpl 클래스는 다음과 같이 작성된다.
        ![image](https://user-images.githubusercontent.com/73324807/114135659-8732a080-9944-11eb-8256-c0a641ced938.png)

        
        + NamerServiceImpl의 메소드를 다른 클래스는 NamerServiceApp에서 참조하기 위해서 NamveService 인터페이스를 Type 으로 가지는 클래스 인스턴스와 클래스자체를 Type으로 가지는 클래스 인스턴스를 생성하면 다음과 같다.
       ![image](https://user-images.githubusercontent.com/73324807/114135695-96b1e980-9944-11eb-9362-81c19a4ebbd1.png)

        
        + 하나의 클래스에 여러 개의 인터페이스를 활용하는 경우 클래스의 메소드를 호출하는 클래스에 따라 다르게 노출시킬 수 있다. 이 경우에는 어떤 인터페이스를 Type으로 활용하여 클래스 인스턴스를 생성하는지에 따라 외부에 어떤 메소드가 노출되는 지 결정된다. 그림은 하나의 클래스 NameServiceImpl에 두 개 의 인터페이스를 활용하는 형태이다. CustomerService 인터페이스에서 getCustomer()만 메소드로 가지고 있기 때문에 CustomerService를 Type으로 생성된 클래스 인스턴스에서는 getCustomer()만 호출하여 활용이 가능하다. 이 경우 Class에서 제공하는 메소드를 호출 활용하는 클래스에 따라 다르게 노출시켜 활용할 수 있도록 캡슐화 하게 된다.
        ![image](https://user-images.githubusercontent.com/73324807/114135732-a5000580-9944-11eb-89ad-24e4d4a41db8.png)
        
        + 자바 인터페이스를 활용하는 다른 사례로는 하나의 인터페이스에 클래스가 다수 존재하는 경우
        + 흔히 컴포넌트를 만드는 가장 중요한 이유로는 현재 구현된 기능을 다른 기능으로 쉽게 교체하여 활용할 수 있도록 하는 것
        + 인터페이스를 같은 것으로 활용하는 클래스가 있다면 기존 코드의 수정 없이 그대로 교체하여 활용할 수 있다.
        + 컴포넌트 기반의 개발에서는 인터페이스를 잘 설계하고 이를 활용하여 개발하는 것이 중요
        + 인터페이스가 잘 설계되어 있으면 특정한 기능의 모듈을 상황에 따라 교체하여 활용하는 것이 가능해진다.
        + 대표적인 예로 JDBC 드라이버의 경우 Oracle, MySQL 등 활용하는 DB가 달라져도 같은 역할을 수행해야 하므로 인터페이스를 준수하는 것이 필수적이다. 다음과 같이 두 개의 클래스 OracleImpl과 MySQLImpl가 하나의 인터페이스 DBService 인터페이스에 정의된 두 개의 함수 connect와 select는 반드시 구현이 되어야 한다. 하나의 인터페이스를 참조하고 있기 때문에 두 개의 클래스는 서로가 교체가 되어도 다른 코드에는 영향을 미치지 않게 된다.
        + 만약 인터페이스를 Type으로 선언하지 않고, 클래스로 Type을 선언하였다면 클래스를 교체할 때 두 개의 클래스 Type이 동일해야만 하는 지를 먼저 확인해야 한다. 클래스 Type이 일치하는 경우는 클래스 전체 함수나 변수 등이 일치해야 되기 때문에 새로운 동일 Type 클래스를 작성하거나 Type이 같은 지를 확인하는 작업은 인터페이스를 활용하는 경우에 비해 매우 어렵다.
        ![image](https://user-images.githubusercontent.com/73324807/114135779-b6e1a880-9944-11eb-92b5-4b071d6e8bb2.png)

        
        
    2. DI개념
        + 인터페이스를 활용하는 경우 동일한 Type을 유지할 수 있어 컴포넌트 구현과 활용에 유리하다.
        + 특정한 클래스를 활용하다가 비즈니스 로직 변경 필요 등의 이유로 다른 클래스로 교체해야하는 경우가 발생될 수 있다.
        + 보편적인 방법은 new로 생성된 클래스를 직접 변경하는 것이다.
        + 만약 참조하고 있는 클래스가 수십개, 수백개가 되는 경우 굉장히 어려운 작업이 될 것이다.
        + 만약 클래스의 소스코드가 없는 경우는 어떻게 해야할 것인가? 
        + 이 때 등장한 개념이 DI(Dependency Injection)
        + DI는 클래스 인스턴스를 생성할 클래스를 직접 소스코드에 지정하지 않고 인터페이스를 활용하여 Type만 지정한다.
        + XML설정파일이나 annotation을 활용하여 실제 인스턴스를 생성할 클래스를 지정하게 된다.
        + 만약 다른 클래스로 교체를 해야 되는 경우에는 소스코드를 수정할 필요가 없이 XML 설정 팡리이나 annotation 정보를 수정하여 적용이 가능하다. Spring을 활용하지 않는 일반 자바 환경이라면 컴파일시에는 에러가 발생되지 않으나, 실행 시에 Class Not Found 에러가 발생하게 된다.
        + Spring이 동작하면서 설정파일이나 Annotation에 등록된 클래스 정보를 읽어서 동작시점에 Dependency를 생성하게 된다.
        + DI를 활용해서 소스코드에서 new를 해주는 것과 같은 효과를 어플리케이션이 동작하는 시점에 동적으로 생성할 수 있다. 그림에서 DI를 활용하지 않을 때는 new의 형태로 클래스 인스턴스를 생성하게 되어 있어 다른 클래스로 교체하기 위해서는 소스코드 수정이 필요하다. DI를 활용하는 경우에는 XML설정이나 annotation을 변경하여 Mapping정보를 변경하는 형태로 소스코드 변경이 없이 다른 클래스로 교체가 가능하다. 비즈니스 로직 변화가 많은 환경에서 소스코드의 수정없이 변경에 유연해진다. 클래스가 다른 클래스들 간의 의존성을 소스코드 레벨에서 가지지 않고 설정파일을 변경하여 의존성 변경이 가능해진다. 특정한 기능을 컴포넌트 형태로 만들어서 쉽게 교체해야 되는 경우 효율적으로 활용될 수 있다.
        ![image](https://user-images.githubusercontent.com/73324807/114135816-c19c3d80-9944-11eb-926a-bfeae1b5e591.png)
        + Spring Container는 객체를 생성하고, 객체 간의 의존성을 이어줄 수 있도록 필요한 정보를 제공
        + 이러한 객체를 Bean이라고 부르며, Spring 프레임워크에서 동작하는 모든 객체는 Bean단위로 활용된다.
        + 어플리케이션이 동작하는 시점에 XML이나 annotation으로 설정된 정보를 Spring Container에 저장하고, 설정 정보를 활용하여 DI를 수행하여 결과적으로 Spring에서 활용가능한 객체 형태인 bean을 생성하게 된다.
        + 소스코드 레벨에서는 클래스가 어떤 클래스를 참조하고 있는 지 알 수 없고, 어플리케이션이 동작하는 시점에 설정파일을 통해서 클래스에 대한 의존성이 결정되게 되므로 이를 IoC(Inversion of Control)이라고 한다.
        + 클래스 의존성의 결정이 소스코드에 있지 않고 외부에서 결정되어 활용되는 형태로 일반적인 어플리케이션이 동작과 반대되는 개념으로 IoC(제어의 역전)라고 불린다.
        ![image](https://user-images.githubusercontent.com/73324807/114135829-c8c34b80-9944-11eb-99de-aee221227fd5.png)
        + Spring Container의 정보는 ApplicationContext에 의해 관리된다. ApplicationContext는 Bean 생성 및 DI, 생명주기를 관리하는 BeanFactory의 기능과 Spring AOP, 메시지 리소스 처리, 이벤트 처리 등의 기능을 제공. ApplicationContext는 BeanFactory의 기능을 모두 제공하므로 일반적으로 ApplicationContext를 활용한다. Spring Container 정보를 생성하고 "foo"라는 bean을 찾는 방법은 다음과 같다. 다수의 Spring 설정 파일(Bean 설정, AOP 설정, 트랜잭션 설정, Data source 설정 등)을 일겅서 context를 생성하여 활용한다.
        ![image](https://user-images.githubusercontent.com/73324807/114135851-cfea5980-9944-11eb-8e42-cb50e79ef9b8.png)
        

    3. DI 활용
        + DI를 설정하기 위해 활용하는 방법으로 XML을 활용하는 방법과 annotation을 활용하는 방법
        + XML을 활용하는 방법은 설정이 불편하고 어려운 단점, XML 파일만 분석시 모든 클래스들 간의 의존성을 파악할 수 있는 장점
        + Annotation의 경우 소스코드에 annotation이 산재되어 있어 의존성 파악은 어려운 점, 편리한 설정 활용.
        + XML 설정의 경우 Spring 기반으로 구현된 솔루션, 플러그인, 프레임워크 등을 활용할 때 많이 활용되고, 일반 비즈니스 로직 구현은 annotation을 활용하는 것이 일반적이다.
        + 서비스 클래스는 비즈니스 로직을 처리하는 클래스.
        + DAO는 DB와 연동하여 정보를 처리하는 클래스로 표준프레임워크에서는 MyBatis(이전 버전 iBatis)를 활용하여 DB작업을 수행.
        ![image](https://user-images.githubusercontent.com/73324807/114135873-d8db2b00-9944-11eb-9257-094cedb00f5a.png)
        + 비즈니스 로직인 웹 어플리케이션의 경우 Controller클래스에서 호출된다. 제일 처음 해야할 것은 인터페이스 구현.
        ![image](https://user-images.githubusercontent.com/73324807/114135896-ded10c00-9944-11eb-9c6f-5144bef8ee36.png)
        1. XML 설정을 활용한 DI
            + XML 설정파일은 <beans/>를 root로 가지며, <bean/>을 사용하여 의존성을 설정한다.
            + Spring Container에 여러 설정파일을 읽어 활용할 수 있기 때문에 설정 내용이 너무 많은 경우에는 XML 설정을 여러 개의 파일로 구성한다. 또한, DI, AOP, 트랜잭션, 메시지 등 설정 내용에 따라 개별 파일을 구성하는 것이 일반적이다. 다음의 XML설정은 두 개의 bean을 설정하고 있다. Bean은 id를 가지고 실제 클래스를 Mapping하고 있다. 클래스 정보는 Spring Container에 id와 함께 저장되어 어플리케이션이나 다른 bean에서 bean의 id로 해당 클래스 정보를 요청할 때 정보를 제공하게 된다. customerXML의 id를 가지는 bean은 실제 lab.CustomerXMLServiceImpl 클래스이며, property속성(custXMLDAO)이 정의 되어 bean id가 customerXMLDAO bean을 레퍼런스(ref)하고 있으며, 서비스 클래스에서 DAO클래스를 참조하기 위한 DI설정에 활용된다. 레퍼런스 되는 Bean은 id가 custoemrXMLDAO이고, 클래스는 lab.CustomerXMLDAO로 Mapping 되어 있다. Property이름은 클래스에서 클래스 정보를 받아오기 위해 정의하는 setter method에서 첫 글자를 대문자로 바꾸어 메소드 명으로 활용된다. 설정에서 customerXML의 경우 CustomerXMLServiceImpl 클래스의 setter 메소드 명으로 setCustXMLDAO으로 정의한다.
            ![image](https://user-images.githubusercontent.com/73324807/114135937-ec869180-9944-11eb-824a-ff6ac8dee6c5.png)
            
            + XML로 DI를 설정하는 클래스 CustomerXMLServiceImpl은 인터페이스를 참조하여 구현되며, 인터페이스에 설정된 두 개의 메소드 getCustName과 getCustGrade를 반드시 구현해야 한다. DAO를 호출하여 전달 받은 결과 값을 반환하도록 구현 되었다. private CustoemrXMLDAO xmlDAO; 로 Type만 선언되어 있고, new로 인스턴스 생성이 되지 않았는데 xmlDAO.getCustName(id)의 형태로 메소드를 호출하고 있다. Spring을 쓰지 않는 환경이라면 실행시점에 Class Not Found 에러가 발생되는데, DI를 활용하여 설정에 있는 클래스 정보를 setter method에서 치환하여 new를 실행한 것과 같이 인스턴스를 생성하게 된다. setCustXMLDAO에서 cmlDAO의 변수로 XML설정파일에 property로 설정 되어 있는 클래스 정보 (lab.CustomerXMLDAO)를 읽어와서 매핑하게 된다.
            
            ![image](https://user-images.githubusercontent.com/73324807/114135955-f4463600-9944-11eb-9c96-3bf1cd0f108f.png)
            
            + DAO는 서비스에서 호출되어 전달 받은 문자 값에 “ eGovFrame XML”과 “ S XML”을 추가하여 반환하도록 되어 있다. XML설정에는 bean id가 customerXMLDAO로 설정되어 있고, 실제 클래스는 lab.CustomerXMLDAO이며 DI를 위해 서비스 클래스에 property 속성으로 레퍼런스 되어 있다.
            ![image](https://user-images.githubusercontent.com/73324807/114135984-fdcf9e00-9944-11eb-88be-3dcdecbe8d1a.png)
        2. Annotation 설정을 활용한 DI
            + Annotation은 소스코드에 직접 코딩을 하는 것이 아니라 @의 형태로 메타데이터를 삽입하는 것을 의미한다. 비즈니스로 로직에는 영향을 주지 않고 소스코드에 대한 실행이나 설정 정보를 추가한다. Annotation을 활용하여 DI를 설정하기 위해서는 Spring에서 annotation 활용을 위한 component-scan 정보를 설정해주어야 한다. Spring Container가 실행 될 때 base package 하위 소스코드의 Annotation 정보를 읽어서 Spring Container에 저장한다. 아래 설정(context-common.xml)에서는 패키지 lab 이하의 모든 소스코드를 스캔하여 annotation 정보를 획득하여 Spring Container에 저장하게 된다.
            
            ![image](https://user-images.githubusercontent.com/73324807/114136019-07f19c80-9945-11eb-8818-4020653a928b.png)

            
            + Bean을 설정하기 위해 클래스 위에 역할별로 annotation을 기술한다. 비즈니스 로직을 구현하는 서비스 클래스는 @Service, DAO는 @Repository로 정의 한다. MVC에서 소개하게 되는 Controller 클래스에는 @Controller를 정의한다. Bean 이름은 @Service(“customer”) 와 같이 정의하며, 이름이 지정되지 않으면 클래스 이름의 첫 글자를 소문자로 바꾸어 자동으로 지정한다. 설정된 bean 정보를 활용하여 DI를 설정하기 위해서는 @Resource나 @Autowired를 활용한다. Private CustomerAnnotationDAO customerdao;의 형태로 Type이 지정되어 있으나 new로 인스턴스를 생성하지 않고, @Resource(name=”custoerdao”)의 형태로 DI를 수행하였다. @Resource의 경우에는 bean의 이름을 지정하여 DI가 가능하며, @Autowired의 경우에는 같은 Type (Interface)를 활용하는 class를 자동으로 매핑하여 DI를 수행한다. 같은 Type이 다수 존재하는 경우는 에러가 발생되므로 유의하여야 한다. XML설정과 annotation설정을 통한 DI는 서로 교차도 가능하다. 즉 XML로 설정된 bean을 annotation을 활용하여 DI를 설정할 수 있고, 반대로 annotation으로 설정된 bean을 XML을 활용하여 DI 설정할 수 있다. Annotation을 활용한 DI 설정은 다음 그림과 같다. @Controller, @Service, @Repository로 bean이 설정되어 있고, 이를 DI로 활용하기 위해 @Resource로 참조 설정 되었다.
            
            ![image](https://user-images.githubusercontent.com/73324807/114136049-150e8b80-9945-11eb-9b9c-6cb6317ff75e.png)
            
            + @Service를 활용하여 customer 이름으로 bean이 설정되어 있다. Customerdao 이름으로 설정된 DAO bean을 활용하기 위해 @Resource로 참조 설정 하였다.
            
            ![image](https://user-images.githubusercontent.com/73324807/114136080-1dff5d00-9945-11eb-80e5-2f6bc19115f2.png)

            
            + @Repository를 활용하여 customerdao 이름으로 bean이 설정되어 있다. 서비스 클래스에서 @Resource로 참조 설정되고 메소드 호출 된다.
            ![image](https://user-images.githubusercontent.com/73324807/114136098-25266b00-9945-11eb-99bd-1e47650e6e68.png)
            
        3. Client 어플리케이션 실행
            + CustomerXMLServiceImpl이 동작하는지 확인하기 위해서 getCustName과 getCustGrade를 호출하는 자바 어플리케이션을 작성 한다. 자바 어플리케이션은 만들어진 서비스를 활용하는 Client 역할을 수행하기 때문에 XML이나 Annotation을 통한 DI 설정을 하지 않고, Spring Container에서 bean을 검색하여 정보를 얻어오는 형태로 활용하게 된다. XML이나 Annotation을 활용하여 DI설정을 하는 경우는 클래스간 연관이 높으면서 변경 가능성이 있는 경우에 변경 유연성을 높이기 위해서이다. 다른 클래스에서 기능만 호출하여 사용하는 경우는 연관성을 없애는 것이 중요하다. 이러한 경우 CustomerServiceApp 클래스 에서와 같이 Spring Container에서 bean id로 검색하고 bean 정보를 얻어오게 지원하면 기능 제공자와 사용자 간의 loosely coupling 된 형태로 의존성을 없애고 유연하게 활용할 수 있다.
            ![image](https://user-images.githubusercontent.com/73324807/114136132-353e4a80-9945-11eb-9296-bff1569011b3.png)
            ![image](https://user-images.githubusercontent.com/73324807/114136173-412a0c80-9945-11eb-82a0-778ee8067c70.png)

            + 어플리케이션을 실행하면 다음과 같이 결과가 출력되는 것을 확인할 수 있다. XML에서는 id를 “1”로 전달 했고, annotation에서는 id를 “2”로 전달하여 서비스 클래스와 DAO 클래스를 거쳐서 결과 값을 전달 받았음을 확인 할 수 있다. 빨간색으로 에러 표시가 되는 부분은 로그를 생성할 log4j파일이 없어서 발생되는 것으로 제7장에서 학습하게 되며, 실행에는 지장이 없다.
            
            ![image](https://user-images.githubusercontent.com/73324807/114136196-4c7d3800-9945-11eb-85b0-0d8a85e942ff.png)

            
        4. Test 코드 실행
            + 단위테스트는 소스코드의 중요 로직의 메소드를 실행시켜서 결과를 확인 할 수 있도록 한다. 메소드의 실행결과가 특정한 값으로 예상되는 경우 일치하는지 여부를 확인하여 일치하면 테스트가 Pass 되어 아무런 메시지가 출력되지 않지만, 일치하지 않는 경우는 에러메시지를 출력하게 된다. 이를 위해 표준프레임워크에서는 JUnit을 활용하여 테스트 케이스를 작성하여 실행한다. 먼저, spring-test와 JUnit 라이브러리 설정을 확인하여야 한다. pom.xml에 다음과 같이 의존성 설정이 되어 있는지 확인한다.
            ![image](https://user-images.githubusercontent.com/73324807/114136225-54d57300-9945-11eb-9ffb-64b512a2fbd8.png)
            + Maven 기반 디렉터리 구조에서 테스트를 위해 src/test/java와 src/test/resources가 정의되어 있다. Test 코드는 src/test/java 밑에 위치하게 되며, 테스트에서 활용되는 설정파일은 src/test/resources 밑에 정의되어야 한다. 따라서 src/main/resources에 있는 설정파일을 src/test/resources 밑으로 copy해야 한다. Spring 프레임워크에서 JUnit을 지원하기 위해 Spring Container를 실행할 수 있도록 annotation 기반 기능을 제공하고 있다. @RunWith은 Spring 기반으로 JUnit을 실행하도록 Runner를 지정하는 역할을 하고 있다. @ContextConfiguration은 경로에 해당되는 설정파일을 읽어서 Spring Container를 생성하여 JUnit 테스트 프로그램에서 접근하여 활용될 수 있도록 한다. 테스트케이스들은 @Test의 형식으로 설정되어 메소드를 직접 호출하지 않아도 JUnit이 실행될 때 자동으로 실행된다. 테스트 결과를 판별하기 위해 수행이 정상적일 때 결과값과 실제 수행된 결과값을 비교하여 두 개가 같을 경우에는 아무런 동작도 하지 않으나, 다를 경우 테스트 실패라는 에러 메시지를 출력하게 된다. assertEquals의 경우 예상 결과 값과 실제 수행된 결과 값을 비교하여 두 값이 다를 경우 에러메시지를 출력한다. 이외에도 assertNotEquals, assertTrue, assertFalse, assertNull, assertNotNull 등 많은 메소드를 제공하고 있다. 테스트를 수행하기 전후에 데이터의 준비, 결과값 처리 등 필요한 작업이 있을 경우 테스트케이스 수행 전 후에 자동으로 실행 될 수 있도록 @BeforeClass, @AfterCalss, @Before, @After의 annotation을 제공하고 있다. JUnit에서 활용되는 annotation들은 다음 표와 같다.
            
            ![image](https://user-images.githubusercontent.com/73324807/114136239-5bfc8100-9945-11eb-8c06-3034a1e99972.png)
            + 앞에서 어플리케이션으로 실행되었던 Customer서비스 실행을 JUnit으로 실행하게 되면 다음과 같다. @ContextConfiguration에서는 test 환경에서 활용될 설정 파일 위치를 지정하게 되며, src/test/resources 밑의 설정 정보를 읽어오게 된다. JUnit이 실행되게 되면 @Test로 설정되어 있는 테스트케이스가 실행되게 되며, assertEquals가 실행되어 예상 값과 결과 값을 비교하여 결과를 출력하게 된다.
            ![image](https://user-images.githubusercontent.com/73324807/114136268-6585e900-9945-11eb-9feb-dfda81d46151.png)
            + 테스트 코드의 실행은 CustomerServiceTest.java를 선택하고 마우스 오른쪽 버튼을 눌러서 Run As > JUnit Test를 선택하여 실행한다. 테스트가 성공한 경우에는 아무런 출력이 없이 녹색 막대가 보여지게 된다. 테스트가 실패한 경우에는 실패 메시지와 함께 빨간색 막대를 보게 된다. 테스트 실패의 경우는 에러가 발생된 경우와 정상적으로 실행은 되었으나 assert 문의 조건을 만족하지 못하는 경우 발생된다. (assertEquals의 경우 예상 값과 수행 결과 값이 다른 경우 실패)
            ![image](https://user-images.githubusercontent.com/73324807/114136294-6f0f5100-9945-11eb-9e6e-2c6780990f01.png)
            ![image](https://user-images.githubusercontent.com/73324807/114136305-759dc880-9945-11eb-8e65-567c7255fbfd.png)




7. Logging
    + 표준프레임워크에서 Log정보 참조를 위해 콘솔화면, File, DB를 활용할 수 있도록 log4j기반으로 기능을 제공하고 있다.
    + Log4j는 설정을 통해 개발자에게 필요한 정보를 출력할 수 있도록 설정할 수 있으며, Log레벨 조정을 통해서 필요한 정보가 전달 될 수 있도록 지원한다. 개발 시에는 DEBUG레벨로 상세한 정보를 참조하고 운영 시에는 불필요한 메시지가 출력되지 않도록 INFO, ERROR 레벨로 조정하여 소스코드 수정 없이 설정파일의 수정만으로 제어가 가능하다.
    1. Logging 개요
        + Logging은 시스템의 개발이나 운영 시에 발생할 수 있는 어플리케이션 내부 정보에 대해서 시스템의 오부 저장에 기록하거나 화면 등에 출력하여 디버그 또는 시스템의 상황 파악을 쉽게 할 수 잇도록 지원하는 서비스이다. 디버그를 위해 System.out.println()을 사용하기도 하는데 예제 프로그램 등 간단한 거이 아닌 실제 프로젝트 환경에서는 사용하지 말아야한다. System.out.println()을 호출하게 되면 디스크 I/O 동기화 처리가 되기 때문에 전체적인 시스템의 성능이 저하될 수 있고, System.out.println()으로 디버그 처리한 부분을 일일이 주석처리, 해제를 하는 것은 개발 및 운영의 효율성을 떨어트릴 수 있다. 표준프레임워크에서는 Apache log4j를 활용하여 logging을 지원.
            + 서브시스템(패키지) 별로 상세한 Log 정책 부여
            + 날짜형식, 시간형식 등 다양한 형식의 Log 메시지 형태 지정
            + 다양한 매체(File, DB, Mail 등)에 대한 Log 관리 기능
            + 레벨(debug, info, warn, error 등) 별로 로그를 기록
        + 표
            + Logger : Log파일을 작성하는 클래스로 Log를 기록할 대상을 패키지 또는 클래스 이름으로 지정하고 이에 대한 로그레벨과 Appender를 지정
            + Appender : Log를 출력하는 위치로 화면, 파일, DB 등 지정. 화면출력의 경우 console 지정.
            + Layout : Appender의 출력 포맷으로 날짜, 시간, 클래스명 등의 정보를 Log 내용으로 지정
        
        + Logger에서 Log레벨을 지정할 수 있으며, 지정된 Log 레벨보다 높은 메세지도 함께 출력
        + ex) Log 레벨이 ERROR이면  ERROR 이외 메시지는 출력되지 않는다. 레벨이 DEBUG로 지정되면 레벨이 높은 INFO, WARN, ERROR 메시지도 함께 출력된다. 개발 시에는 Log 레벨을 DEBUG로 두고 메소드 실행결과 등 확인이 필요한 Log를 출력하고, 실제 운영 시에는 Log 레벨을 INFO로 두고 중요 정보 확인 및 에러 메시지 등을 관리하는 것이 일반적이다.
        + 표
            + Error : 처리 중 문제가 발생한 상태
            + Warn : 처리 가능한 문제이지만, 향후 시스템 에러의 원인이 될 수 있는 경고성 메시지
            + Info : 로그인, 상태 변경 등 정보성 메시지
            + Debug : 개발시 디버그 용도로 사용할 메시지
            
    2. Log4j 활용
        + Log4j를 활용하기 위해서는 egovframe.rte.fdl.logging 참조 가능하도록 설정이 필요.
        + pom.xml에 직접 설정하지 않아도 전자정부 표준프레임워크에서 반드시 설정이 필요한 egovframe.rte.psl.dataaccess 와 egovframe.rte.ptl.mvc 참조설정을 하면 의존성 설정에 의해서 자동으로 설정이 된다.
        + Log4j-core-2.1.jar 및 log4j-api-2.1.jar 등 필요 라이브러리 의존성이 설정되어 있는 것을 확인할 수 있다. 아래 설정은 egovframe.rte.fdl.logging에 설정되어 있는 내용과 개발 환경에서 설정된 라이브러리 화면이다.
        
        ![image](https://user-images.githubusercontent.com/73324807/114141623-d086ee00-994c-11eb-8f4d-86e137296aa6.png)
        
        + Log4j 활용을 위해서는 Logger, Appender 를 설정하는 설정파일(log4j2.xml)이 필요하다.
        + 설정파일은 src/main/resources 밑에 위치한다. 설정파일에 Default로 설정되는 logger는 Root level로 표현된다.
        + ERROR가 default 레벨로 표시되어 logger가 지정되지 않으면 Error 레벨의 Log만 출력.
        + Spring 프레임워크에서 출력하는 메시지는 logger명이 "org.springframework"로 되어 있고 INFO 레벨로 지정되어 있다. 소스코드에 해당되는 logger 이름은 "lab"으로 되어 있고 레벨은 INFO로 설정되어 있다.
        ![image](https://user-images.githubusercontent.com/73324807/114141648-d977bf80-994c-11eb-8337-b534e18a6ed7.png)

        
        + Log를 출력하기 위해서는 먼저 LogManager의 getLogger() 메소드 호출을 통해 Log 출력에 활용할 logger를 설정해주어야 한다. getLogger()는 static 메소드이므로 인스턴스 생성을 하지 않고 호출이 가능하다. getLogger()에 string 값이 입력되면 입력 값에 해당되는 Logger를 활용할 수 있게 된다. Null 값이 입력되면 Class 이름이 입력된다. 앞에서 logger의 이름을 "lab"으로 입력하였기 때문에 getLogger("lab")이라고 입력을 해도 되지만, getLogger(.class.getName())의 형태로 패키지와 클래스네임을 입력하도록 하면 패키지 이름이 입력되어 logger "lab"을 입력한 것과 같게 된다. Logger가 설정되면 출력하고자 하는 Log레벨을 지정하고 출력하고자 하는 메세지를 Log로 출력한다.
        ![image](https://user-images.githubusercontent.com/73324807/114141679-e3012780-994c-11eb-888d-a73deba96274.png)
        ![image](https://user-images.githubusercontent.com/73324807/114141705-ec8a8f80-994c-11eb-9f18-a2e03cb15896.png)





8. AOP(Aspect Oriented Programming)
    + 프로그램 개발할 때 로깅, 트랜잭션, 예외처리 등 반복적 처리가 되어야 하고, 업무 로직 코드와 혼재되어 전체적으로 소스코드가 복잡해지고 특정 라이브러리에 의존성도 발생되게 된다. 이러한 문제를 해결하기 위해 기술적인 처리가 필요한 영역을 별로 공통모듈로 분리하고 대상과 발생시키는 시점을 정의하여 자동적으로 실행될 수 있도록 하여 변경이 용이하고 재사용성을 높일 수 있도록 한다.
    1. AOP 개요
        + AOP는 객체지향 프로그래밍을 보완하는 개념으로 어플리케이션을 객체지향적으로 모듈화하여 작성하더라도 다수의 객체들에 분산되어 중복적으로 존재하는 공통모듈이 여전히 존재. 이를 AOP에서는 횡단관심이라고 부른다. 업무 처리를 하는 모듈(주된 관심, primary concern)에서 로깅, 보안, 트랜잭션, 예이처리 등의 기술적인 처리를 수행하기 위한 소스코드가 포함이 되어 업무 로직에 집중하기가 힘들다. 또한, 기술적 처리를 위한 모듈 들과의 의존성이 생겨 어플리케이션 변경 시에 유연성이 떨어진다. 일반 어플리케이션 환경과 AOP가 적용된 환경을 비교해 보면, AOP가 적용되지 않으면 모듈안에 주된 관심과 횡단 관심이 섞여 존재하게 된다. 그림에서처럼 업무 모듈에 기술적 처리를 위한 cross concern이 섞여서 존재한다. AOP를 활용하면 기술적 처리를 위한 모듈을 advice로 분리하여 별도로 존재하게 한다. 별도로 존재하는 advice가 필요한 시점에 동작할 수 있도록 동작하는 대상과 동작되는 시점을 규칙형태로 정의한다.
        ![image.png](attachment:image.png)
        + 예를 들어 로그를 처리하기 위해 log4j를 활용한다면 log4j 모듈에 대한 의존성이 생기게 되며, 업무 처리 모듈에서 로그를 출력하기 위한 소스코드가 포함되게 된다. 이러한 문제를 해결하기 위해서는 기술적 처리를 위한 cross concern을 advice로 별도로 분리하고, 업무처리 모듈 중에 어느 메소드(point cut)에서 어느 시점(joint point)에 처리를 해야 되는지를 규칙형태로 정의한다. 정해진 규칙에 해당되게 되면 advice의 정해진 메소드가 실행된다.
        ![image-2.png](attachment:image-2.png)
        + 그림에서 일반 어플리케이션은 모든 모듈이 log4j에 의존성을 가지고 있으나, AOP를 활용하게 되면 분리된 advice에만 log4j의존성을 가지게 되며, 주된 관심인 업무 모듈에서 cross concern인 log4j를 호출하는 모듈을 포함할 필요가 없어진다. 정해진 규칙에 해당하게 되면 자동으로 실행되도록 한다.
        ![image-3.png](attachment:image-3.png)
        + AOP를 활용하여 얻게 되는 효과
        ![image-4.png](attachment:image-4.png)
    2. XML을 활용한 AOP 설정
        + AOP 활용을 위해 설정파일에 advice, point cut, joint point를 설정한다. 파일명은 임의로 정의를 해도 되지만 구분을 위해 주로 context-advice.xml로 명명한다. 설정은 aop라는 prefix를 활용하여 설정을 한다. *lab..*Impl.*(..)의 표현은 lab 패키지 밑에 Impl로 되어 있는 모든 클래스의 모든 메소드에 대해서 AOP를 적용한다는 것이다. Joint point의 설정은 before, after-returning, after-throwing, after, around에 대해서 각각 해당되는 poing cut id를 지정하고 실행할 advice의 메소드를 지정한다. Before joinit point의 경우 point cut은 "targetMethod"이고 메소드가 실행되기 전에 "beforeTargetMethod"가 실행되게 된다. After_returning의 경우 "afterReturningTargetMethod"가 실행되며 결과값을 "retVal" 변수로 받아오게 된다. 로그 등을 출력하는 등 결과 값을 활용할 경우 사용된다.
        ![image-5.png](attachment:image-5.png)
        ![image-6.png](attachment:image-6.png)
        + 앞에서 설명된 여러 지정자를 활용하여 Point cut을 설정하는 예제를 보면 다음 표와 같다. 정의 예제에서 execution은 메소드를 지정하고 within은 타입을 기준으로 설정하는 차이가 있다. Execution을 사용하게 되면 메소드별로 AOP를 설정하게 되고, within은 인터페이스 별로 설정하게 된다. Execution에서 모든 메소드를 선택하게 되면, within으로 설정한 것과 같은 형태로 동작하게 된다. 또한, 두 개 이상의 표현식이 조합이 되어 활용 될 수 있다. IF문처럼 and (&&), or (||), not (!)의 연산자를 활용하여 point cut을 정의 할 수 있다.
        ![image-7.png](attachment:image-7.png)
        ![image-8.png](attachment:image-8.png)
    3. Advice 설정
        + AOP설정을 위해 AdviceUsingXML advice를 설정하였다. Advice에서 before, After-returning 등의 Joint point에서 실행될 메소드를 정의한다. Before의 경우 메소드가 수행되기 전에 실행되며, 메소드가 호출되어 전달 되는 인수(argument)의 값을 호출하여 받아 올 수 있다. 소스코드에서 before는 해당 클래스 및 메소드 이름을 출력하고, 전달 받은 인수 값을 출력한다. Advice가 실행되면 "Advice Using XML beforeTargetMethod" 가 출력되고 클래스명과 메소드명이 출력된다. 전달 받은 인수가 있는 경우에 인수 값도 함께 출력된다.
        ![image-9.png](attachment:image-9.png)
        ![image-10.png](attachment:image-10.png)
        + After returning의 경우 메소드 실행이 정상적으로 실행된 후에 수행된다. 결과 값은 XML 설정에 returning으로 명시된 변수로 전달 받게 된다. 소스 8-1에서 retVal로 정의되었다.
        ![image-11.png](attachment:image-11.png)
        + After throwing advice는 메소드 실행 중 에러 등의 예외 사항이 발생되었을 때 수행되며, exception 내용을 전달 받는다.
        ![image-12.png](attachment:image-12.png)
        ![image-13.png](attachment:image-13.png)
        + After는 메소드 실행 후에 정상종료 및 예외발생 등 결과에 상관없이 무조건 수행된다. IF문에서 finally와 비슷한 역할을 하며, 주로 리소스 해제 작업과 같은 마무리 작업을 위해 활용한다.
        ![image-14.png](attachment:image-14.png)
        + Around는 메소드 실행 전후에 수행된다. 결과 값을 변환해야 될 경우 활용한다. 결과 값을 전달 받아서 가공한 후 리턴할 수 있다. Proceed() 앞은 메소드 실행 전에 수행이 되고, 뒤는 메소드가 실행된 다음에 수행된다.
        ![image-15.png](attachment:image-15.png)
        + Point cut의 메소드가 실행될 때 joint point에 따른 advice 실행순서를 정리해보면 다음과 같다. 정상실행과 예외발생의 경우 모두 before, around (실행 전)의 순서로 수행이 되며, 대상 메소드가 실행된 후에 정상실행의 경우 around(실행 후), after, after-returning의 순서로 실행이 된다. 예외 발생의 경우는 after를 실행하고 after-throwing을 실행하고 종료하게 된다.
        ![image-16.png](attachment:image-16.png)
    4. AOP 활용 및 실행결과
        + sayHello()와 sayError()의 두 개의 메소드를 가지는 HelloWorldServiceImpl 서비스를작성하였다. HelloWorldApp에서 호출되어 실행되는 형태이며, sayHello()는 message를 인수로 받아서 문자열을 생성하여 결과를 출력하게 된다. Before advice에서 전달 받는 인수를 출력하게 되어 있어 내용 확인이 가능하며, After returning에서 결과 값을 리턴 할 때 결과를 출력하게 되어 있어 결과 확인이 가능하다. sayError()는 After throwing이 제대로 수행되는지를 확인하기 위해 고의로 0으로 나누어 에러를 발생시켰다.
        ![image-17.png](attachment:image-17.png)
        + 실행하기 전에 주의할 점은 예제에서 해당 advice에서 로그를 출력하도록 되어 있는 debug 레벨로 설정되어 있어 로그레벨이 Debug로 되어야 확인이 가능하다. HelloWorldApp을 선택하고 Run As > Java Application을 선택하여 실행하면 다음과 같은 결과를 얻는다.
        ![image-18.png](attachment:image-18.png)
    5. 표준프레임워크에서 Exception 처리 AOP 활용
        + 표준프레임워크에서 예외 처리를 위해서 AOP를 활용하고 있다. AOP를 활용하지 않으면 모든 메소드에서 예외처리를 중복적으로 구현해야 하는 불편함이 있다. 특히, 예외 종류에 따라서 처리가 다르게 수행해야 할 경우에는 메소드별로 중복적으로 관련로직을 개별 구현해야 한다. 예외 처리를 위한 advice에서는 예외가 BizException, Runtime Exception, 실행환경 Exception인지 예외 종류에 따라서 분기처리가 되어 다른 처리를 수행하게 된다.
        ![image-19.png](attachment:image-19.png)






















































