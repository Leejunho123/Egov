# 전자정부 표준프레임워크 퍼스트 북 
### https://www.egovframe.go.kr/home/ntt/nttRead.do?menuNo=65&bbsId=4&nttId=1449

1. 전자정부 표준프레임워크
    + 공공사업에 적용되는 SW 프레임워크의 표준을 정립
    + 응용 SW 표준화
    + 품질 및 재사용성을 높일 수 있는 기반 제공
    

1. 전자정부 표준프레임워크  
    1. SW 프레임워크 등장배경
        - 메인프레임 시대부터, Client/Server, 시대의 전환인 WEB의 등장 모바일/클라우드 시대까지 변화해오면서, 이제는 누구나 소프트웨어를 사용하고, 사용해야만 생활할 수 있는 시대가 되었다. 최근 들어서는 twitter, Facebook 등 소셜미디어의 등장으로 거대한 데이터들이 날마다 생산. 이러한 데이터를 분석, 활용/처리 하는 데 IT 업계의 대표적인 이슈
        - 가장 중요시 되던 부분 : 자동화, 재사용
        - 기술 발전으로 실시간 처리와 일괄 처리로 구분.
        - 소프트웨어 규모의 대형화 및 복잡화 -> 개발 비용 증대
        - 일관되지 않은 개발 방식 -> 유지보수성 악화
        - 새로운 기술 교육 및 훈련 부족 -> SW 개발 및 운영에 많은 문제점 발생.
        - 이 원인들로 다양한 발전이 있었음

1. 전자정부 표준프레임워크  
    1. SW 프레임워크 등장배경
        1. 소스 재사용
            - 초보적인 재사용 방식으로 과거 코드를 복사해서 사용
        2. 재사용 메소드
            - 복사/붙이기 방식과 동일한 코드가 여러 클래스에서 나오는 것을 지양
            - 라이브러리로 만들어 재사용하는 방식
        3. 재사용 객체
            - 기존의 재사용방식 - 소스 재사용, 재사용 메소드 - 들은 자바뿐만 아니라 다른 언어를 사용할 때도 가능한 방식이나, 확장이 쉽지 않은 방식이었다면, 자바 언어에서는 클래스는 설계하고 상속, 확장하는 방식으로 재사용을 진행.
        4. 디자인패턴
            - 클래스의 재사용 방식이 객체의 수직적인 재사용 방식, 디자인 패턴은 상황적인 문제를 해결해주는 재사용 방식.
            - 메커니즘의 재사용으로 진행
        5. SW 프레임워크
            - 디자인 패턴은 상황에 대한 해결이 가능. 시스템 전체에 대해서는 직접 패턴을 적용하여 문제를 해결.
            - 이러한 문제점을 해결하기 위해 전체 시스템적 관점에서 표준화된 디자인 패턴을 적용한 설계 및 구현체가 SW 프레임워크

1. 전자정부 표준프레임워크
    2. SW 프레임워크 정의
        - SW 프레임워크의 사전적 의미 : 무엇을 이루는 뼈대 혹은 기반 구조.
        - 개발을 도와주는 부분부터 사상에 이르기까지 다양한 범위로 논의.
        - 소프트웨어 시스템에 대한 라이브러리 또는 클래스의 재사용 세트
        - 소프트웨어의 특정 클래스에 대한 재사용 가능한 디자인을 구성하는 클래스틀 협력의 집합 - GoF 패턴
        - 종합 정의
            - 일련의 문제 해결을 위한 추상화된 디자인을 구현한 클래스들의 집합으로 클래스 보다는 큰 규모의 재사용을 지원
            - 구체적이며 확장 가능한 기반 코드, 설계자가 의도하는 아키텍쳐와 디자인 패턴 집합
            - 실전에서 얻은 최적화 개발 경험을 반영한 재사용 가능한 API집합
            - 라이브러리와 달리 어플리케이션의 틀과 구조를 결정, 그 위에 개발된 개발자의 코드를 제어하는 반 제품 성격의 소프트웨어
            
        - 장점
            - 개발용이성
            - 시스템 복잡도의 감소
            - 이식성
            - 품질보증
            - 운영 용이성
            - 개발코드의 최소화
            - 변경용이성
            - 설계와 코드의 재사용성
            
        

1. 전자정부 표준프레임워크
    3. 표준프레임워크 개요
        - 표준프레임워크 전 전자정부 지원사업 시에 대기업의 SW 프레임워크가 도입 활용.
        - 그로 인한 문제점 : 폐쇄적 정책. 자사 SW 프레임워크를 공개, 판매 하지 않아 상호호환성을 보장하기가 어려움
        - 따라서 연속 사업 혹은 유지보수사업의 사업자 변경을 원칙적으로 어렵게 한다는 문제가 있었다.
        - 이미 특정 SW 프레임워크를 활용하여 구축된 소스코드를 다른 SW 프레임워크로 변경이 불가능하기 때문에 SW 프레임워크의 적용은 불가피하게 소스 코드의 종속성 문제를 가지게 됨.
        - 결국 공동 SW 프레임워크 필요성
        - 표준프레임워크는 실행, 개발, 관리, 운영 등 4개의 환경 과 모바일 표준프레임워크, 공통컴포넌트로 구성.
        - 참조프레임워크로 대표적인 오픈소스 SW프레임워크인 스프링 프레임워크 채택
        - OSS를 적용/ 활용하여 구성
        - 전자정부 서비스의 품질향상, 정보화 투자 효율성 향상을 달성
        - 대,중소기업이 동일한 개발기반 위에서 공정 경쟁이 가능하게 된다.
        - 표준프레임워크는 기존 다양항 플랫폼 환경을 대체하기 위한 표준은 아니며, java 기반의 정보시스템 구축에 활용할 수 있는 개발,운영 표준 환경을 제공하기 위한 것.
        - 공공 정보화 사업에 많이 활용되는 인프라 환경과의 호환성 보장
        - 광범위한 보급-확산을 위해 소스 뿐만 아니라 분석-설계 산출물도 함께 공개
        - 다수가 만족하는 표준이 될 수 있도록, 개발 과정에서 다양한 전문가로 구성된 협의회 의견을 청취-반영
        

1. 전자정부 표준프레임워크
    4. 표준프레임워크 활용 고려 사항
        1. 자바 기반의 웹 응용 시스템(WAS가 존재하는 경우)
        2. (2.7 기준) JavaEE(J2EE) 5 혹은 JDK1.5 이상의 환경 (단, 개발환경 2.7 이상에서는 JDK 1.6이상 필요)...
        3. 신규 개발시스템으로써, 기존 시스템과 물리적 혹은 논리적으로 구분되는 경우
        
        + 표준프레임워크는 표준으로써 목적을 만족하기 위하여 아래의 규칙을 준수하여 적용
            - 실행환경은 원칙적으로 변경 없이 활용해야 함
            - 개발환경은 기능의 변경과 추가에 제약사항 없음
            - 공통컴포넌트는 변경 가능하나, 표준프레임워크 아키텍쳐 준수 필요
            

2. 개발환경 구성하기
    1. 개발환경 구성
        - 구현도구, 테스트도구, 형상-변경관리 도구, 배포도구로 구성
            - 구현도구 : 프로그램 개발, 컴파일, 디버그 등 개발자 개별 환경 제공
            - 테스트도구 : 개발자가 단위테스트를 수행하고 결과를 리포팅
            - 형상-변경관리 도구 : 개발자가 작성한 소스코드를 통합하여 버전관리 수행
            - 배포도구 : 형상관리의 소스코드를 통합 빌드하고 개발 서버 등에 배포
        - 개발환경 : 개발자 PC에서 작업이 진행되는 개발자 개발환경과 개발서버 및 운영서버에서 진행되는 서버개발환경으로 구성
        - 개발자 : 개발 환경을 활용 소스코드를 제작, 컴파일 및 테스트를 구행하고 실행 가능한 형태로 빌드
        - 개발자 개인 별 소스코드를 수정하여 commit하거나 update하는 형태로 공동작업 형태 개발.
        - 배포도구는 통합저장된 소스코드를 불러와서 통합 빌드한다.
        - 웹 어플리케이션 서버 등에서 실행이 가능한 형태로 구조화하여 배포
        - 주요 오픈소스
            - 구현도구 : Eclipse, PMD, Maven
            - 테스트도구 : JUnit, EasyMock, DbUnit, EclEmma
            - 형상-변경관리도구 : Subversion, jTrac
            - 배포도구 : Hudson, Nexus, Maven
                - Eclipse : 자바 소스코드를 편집, 컴파일, 테스트, 실행이 가능하도록 지원하는 대표적인 개발도구
                - PMD : Eclipse 플러그인. 룰셋 기반으로 소스코드 오류 등을 검사하여 품질을 높이도록 한다.
                - Maven : 소스코드 컴파일에 필요한 라이브러리를 관리하고 컴파일, 테스트, 빌드 등 작업을 수행
                - JUnit : 단위테스트 코드를 작성하여 테스트하도록 지원한다.
                - EasyMock : 웹 어플리케이션을 실행하지 않고도 테스트가 가능하도록 시뮬레이션 환경을 지원
                - DBUnit : DB 테스트 데이터를 생성 결과가 미리 입력된 결과값과 같은지 비교할 수 있도록 환경 지원
                - EclEmma : 실제 소스 코드에서 단위테스트로 수행된 부분이 어느 정도인지 퍼센트 형태로 정보를 알려주는 coverage 테스트
                - Subversion : 형상관리도구. 소스 통합 버전관리
                - jTrac : 변경관리 이력 등을 추적 가능
                - Hudson : 지속적 테스트와 통합을 지원하는 CI 도구
                - Nexus : Maven 라이브러리 3rd Party로 제공시에 활용
   
            

2. 개발환경 구성하기
    2. 개발환경 설치 및 구성
        - 프레임워크 홈페이지에서 제공하는 교육교재를 활용하는 방법 : 모두 구성. 활용 가능
        - 표준프레임워크에서 개발환경을 내려 받고 Tomcat,JDK 등 필요한 설정을 한다.
        - 기존에 활용하던 Eclipse에 표준프레임워크 플러그인을 설치하여 활용하는 방법
        1. 교육실습교재 사용
            - 교육자료 다운.
            - 표준프레임워크을 처음 사용하는 사용자나 자바에 익숙하지 않은 개발자들은 처음에는 이 방법을 활용하여 사용하는 것을 권장
            - 필요한 소프트웨어 및 설정이 되어 있어 바로 활용 가능
        2. 개발환경 구성
            - Tomcat 등등 다 설치해주고 연동까지 해줘야 한다.
        3. 기존 Eclipse에 플러그 인 설치
            - 개발은 가능. egovFrame전용 도구는 활용 불가.

3. 개발자 개발환경 활용
    1. 구현도구 활용
        - Eclipse Java EE를 기반으로 표준 프레임워크 플러그인이 설치되어 있다.
        - Eclipse 기본화면은 메뉴바, 툴바, 퍼스펙티브바, 4개의 뷰 영역으로 구성
        - 4개의 뷰를 포함하는 전체 영역을 퍼스펙티브, Eclipse Window 전체를 워크벤치라 부름
        - 구현도구는 통합메뉴, 퍼스펙티브, 뷰, 에디터 등을 제공
        - eGovFrame 퍼스펙티브를 선택하면, 메뉴에 eGovFrame 통합 메뉴가 나타나게 된다.
        - 통합메뉴는 유형별 프로젝트 생성, 각종 다이어그램 작성, SQLMap 편집, 공통컴포넌트 생성 등 기능을 제공.
    2. Maven 활용
        1. 라이브러리 의존성 관리
            - 기존에 개발된 수많은 라이브러리를 활용하여 필요한 기능을 쉽게 확장할 수 있다는 장점
            - 종속성 및 버전관리가 어려운 문제
            - 특징 라이브러리를 활용하기 위해서는 참조하고 잇는 다른 라이브러리도 함께 활용이 되어야 한다.
            - A라는 라이브러리가 B와 C라이브러리 기능을 활용하고 있다면 A만 가지고는 활용이 불가능. B,C를 함께 참조
            - 버전 문제
            - 이 모든 라이브러리의 Build Path를 개별적으로 설정은 불가능
            - Maven은 이러한 라이브러리 관리 문제를 해결하기 위해 의존성 설정을 활용하여 라이브러리를 관리
            - 실제 pom파일 dependency가 의존성 설정인데 모든 jar가 들어가 있지 않다. 이는 특정 라이브러리를 다운받을 때 그 라이브러리에도 pom 파일이 존재하여 그 안의 버전에 따른 다른 라이브러리 또한 다운받기 때문. 이는 Maven local repository에 저장되어 있다.
            - pom dependency 예제
                ```
                <dependency>
                 <groupId>egovframework.rte</groupId>  라이브러리 식별 namespace
                 <artifactId>egovframework.rte.ptl.mvc</artifactId>  라이브러리 명
                 <version>{egovframework.rte.version}</version>  버전정보
                 <exclusions>  옵션이며, 충돌 등의 이유로 특정 라이브러리 의존성 제거
                 <exclusion>
                 <artifactId>commons-logging</artifactId>
                 <groupId>commons-logging</groupId>
                 </exclusion>
                 </exclusions>
                </dependency>
                ```
            - 처음 Maven 실행 시 Local Repository에 라이브러리가 없다면 pom.xml의 repository에 기술된 Remote Repository로부터 라이브러리를 다운받게 된다. 사용자가 Nexus 등을 활용하여 개별적 3rd Party 라이브러리를 구성할 수도 있다. 인터넷이 차단된 폐쇄망에서는 필수적으로 별도 Repository를 구성해야함
        2. 빌드 관리
            - Maven에서는 디렉터리 구조를 정규화. 복잡한 설정 없이 컴파일, 패키징 등을 수행가능.
            - 실제 소스파일, 테스트 소스 파일로 구성. resources 디렉터리에는 jar나 war로 패키징 될 때 함께 배포되어야 할 설정파일 등의 리소스가 위치
            - 웹 프로젝트의 경우 webapp 밑에 MVC 설정과 웹 리소스 (HTML, 자바스크립트, 이미지 등)가 위치.
        3. Maven 설정
            - pom.xml : 프로젝트의 정보, 의존성, 빌드 세팅(플러그인) 정보를 포함하고 있다. Maven 프로젝트는 빌드 되어 로컬 또는 원격 Repository에 배포될 수 있기 때문에 자체적으로 GroupId, Artifact Id, 버전 정보를 가짐.
            - 라이브러리 관리를 위한 의존성 관리
            - 컴파일, 패키징 뿐만 아니라 테스트 결과 리포트, java doc 생성과 같은 작업들을 플러그인 설정을 통해서 수행 가능.
            - Maven 은 빌드 작업시에 플러그인을 활용하여 생명주기 단계별로 플러그인을 바인딩하여 작업을 처리.
            - 플러그인의 설정은 pom.xml의 pluginManagement 에 기술.
            - 표준프레임워크에서 설정하여 제공하고 있는 주요 Maven 플러그인 정보
                - complie : maven-compiler-plugin : 소스코드 컴파일
                - test : maven-test-plugin, maven-surefire-plugin : 단위테스트 실행과 리포트 생성
                - package : maven-jar-plugin, maven-war-plugin : 압축파일 생성
                - emma : maven-emma-plugin : Code coverage report 생성
            - maven build 시 모든 필요한 소스들 다운로드
            - maven install 시 compile, test, package, install의 순서로 실행
                - compile : resources 플러그인이 실행, 소스 코드가 copy, compiler 플러그인이 동작하여 컴파일을 수행
                - test : test 플러그인이 실행, 단위테스트 수행, surefire 플러그인을 통해 테스트 결과 리포트 생성
                - package : war 플러그인이 동작되어 war 배포파일 생성.
                - install 단계에서 로컬 repository로 배포.

4. 서버 개발환경 활용
    1. 형상관리 도구 활용
        1. Subversion 개요 및 설치
            + 형상관리 도구는 팀프로젝트 수행시에 개인 개발자들이 작성한 소스코드를 하나의 프로젝트로 통합.
            + 변경된 내용을 버전관리하여 변경 히스토리를 관리하고 필요한 경우 이전 버전으로 변경할 수 있도록 기능을 지원.
            + Subversion은 파일 뿐 아니라 디렉터리도 버전관리를 지원. 변경관리를 변화된 부분만 관리하여 성능이 우수.
            + 윈도우 환경의 서버 VisualSVN을 활용하면 SubVersion을 쉽게 설치할 수 있음.
        2. Revisions
            + 저장소에 저장된 각각의 파일 버전.
            + Commit 시에 일정한 규칙에 의해서 숫자가 증가.
            + Subversion은 변경 발생 시에 전체 단위로 Revision을 갱신하여 관리.
            + 개발 파일 단위로 Revision을 관리하게 되면 전체적으로 소스코드에 변경이 일어난 순서 정보를 알기 어렵게 됨.
        3. Eclipse와 연동
            + Subversion을 활용하기 위해 제일 먼저 해야 하는 일은 프로젝트 최초 commit하는 것.
            + 최초 commit이 되어 Subversion repoistory에 저장.
            + 다른 개발자들이 자신의 workspace로 내려 받아 활용 가능 이를 check out.
            + 그 후에는 commit, update
            + 종종 충돌 가능. 다시 Commit or Update 하면 됨 (Override and Commit, Override and Update)

4. 서버 개발환경 활용
    2. 배포 도구 활용
        1. CI 개요 및 설치
            - 전통적으로 SW 개발은 분석, 설계, 개발, 테스트의 순서로 진행
            - 프로젝트의 위험 요소는 에러, 미개발, 요구사항 미 충족 등의 결함이 프로젝트 후반 특히 오픈 직전에 발견
            - 이러한 문제를 해결하기 위해 소스코드 통합과 테스트를 상시적으로 수행하는 개념이 CI이다.
            - 많은 개발자로 구성된 팀이 작업한 것을 짧은 주기로 통합 및 테스트를 수행하는 소프트웨어 개발 방식이다.
            - commit -> 형상관리 서버에서 통합 -> check out -> Maven 등 도구 활용하여 테스트 및 빌드.
            - 주로 Maven package를 수행하여 테스트 및 배포파일 생성. 개발서버 배포
            - 라이브러리 : Maven deploy를 실행하여 Nexus 등의 원격 Repository로 배포할 수 있다.
            - CI 서버로는 Hudson이 많이 활용되었으나 Sun이 Oracle로 흡수 합병에 따라 기존 Hudson 오픈소스 프로젝트에 변경이 생기면서 Jenkins 프로젝트가 시작되었다.
            - Hudson도 Eclipse에서 오픈소스 프로젝트로 개발이 진행 중에 있으나 Jenkins보다 업데이트 등이 활발하지 못한 상태.
            - 두 개의 CI서버는 거의 동일한 기능을 가지고 있기 때문에 굳이 구별할 필요는 없지만, 사용성 및 향후 발전 측면에서는 Jenkins가 더 유리한 상태이므로 Jenkins 기준으로 설명.
            - war파일 Tomcat 등의 WAS 의 webapp 밑에 압축을 풀어 주는 것으로 설치가 완료.
            - Hudson의 경우도 마찬가지로 설치가능.
            - Jenkins의 경우 WAS까지 패키징하여 윈도우, 맥 등의 실행파일 형태로 설치할 수 있도록 지원하고 있다.
            - 이 경우 별도의 WAS의 설치가 불필요하여 편리하지만 OS에서 자동 실행되는 서비스로 등록되기 때문에 개발 및 테스트 용도로는 관리가 어려울 수 있다.
           
            
            

5. 실행환경 소개
    1. 실행환경 구성
        + 실행환경은 화면처리, 업무처리, 데이터처리, 연계, 공통기반, 배치처리 Layer로 구성
            + 화면처리 Layer : 사용자 인터페이스 및 화면 구현에 필요한 기능과 구조 제공
            + 업무처리 Layer : 예외 처리 및 업무흐름 처리 기능을 제공
            + 데이터처리 Layer : 개발자가 작성한 소스코드를 통합하여 버전관리 수행
            + 연계 Layer : SOAP기반 웹 서비스 기능 제공
            + 공통기반 Layer : 재사용 컴포넌트, 로그 등 개발에 필수적인 기능 제공
            + 배치처리 Layer : 일괄처리를 위한 설정 및 실행 기능 제공
            
        + 실행환경 Layer별로 하위 서비스를 제공. 화면처리 Layer의 경우 기본 패턴인 MVC이외에 국제화, Ajax, 국제화 등 기능을 제공.
        + 데이터처리 Layer 의 경우에는 DB 접속을 위한 DataSource
        + SQL을 XML 설정파일에서 관리 할 수 있도록 지원하는 Data Access
        + 자바코드로 SQL을 대신할 수 있는 ORM 서비스
        + 공통기반 레이어에는 표준 패턴을 제공하는 IOC,AOP와 Logging 등 서비스를 제공
        ![image](https://user-images.githubusercontent.com/73324807/114120956-7ecc6c80-9928-11eb-9710-6d952c20b5e7.png)
        + 표준프레임워크 실행환경에서 서비스 별로 채택 활용하고 있는 대표적은 오픈소스는 다음과 같다.
        ![image](https://user-images.githubusercontent.com/73324807/114120982-88ee6b00-9928-11eb-8ab5-65a70c463d48.png)
        + 표준프레임워크 주요 패턴과 기능은 Spring 프레임워크 기반으로 구성.
        + Spring 프레임워크 : Java 웹 어플리케이션 개발을 쉽게 해주는 오픈소스 SW 프레임워크이다.
        + 인터페이스와 구현으로 구성된 자바 객체는 Spring 컨테이너에 빈 형태로 등록되어 활용된다.
        + Spring 프레임워크는 IoC 컨테이너로 구성되는 CORE, DB를 지원하는 DAO, JPA 등 ORM 메시징 등 Enterprise 환경을 지원하는 JEE, 웹 환경을 지원하는 WEB의 패키지로 구성된다.
        ![image](https://user-images.githubusercontent.com/73324807/114120834-4036b200-9928-11eb-83f9-a6b03da297ae.png)
        ![image](https://user-images.githubusercontent.com/73324807/114120909-68261580-9928-11eb-8667-69019426562d.png)

6. DI
    + 자바프로그래밍 시 구현된 기능을 다른 소스코드에서 활용할 때 설정되어 있는 소스코드 간의 종속성 부분은 재사용에 큰 어려움을 주게 된다.
    + 이러한 문제를 해결하기 위해 DI를 활용하여 소스코드간에 직접적으로 종속성을 가지지 않고, 참조 정보를 XML 설정파일이나 annotation을 활용하도록 한다. -> 소스코드를 직접 고치지 않고 소스코드를 참조할 수 있도록 지원
    1. 자바 인터페이스
        + 자바 인터페이스는 클래스들이 구현해야 하는 동작을 지정하는 데 사용되는 추상형, 클래스들이 지켜야 하는 형식을 정의
        + 인터페이스는 클래스에서 외부로 노출되어 활용되는 변수나 메소드 정보를 제공하여 다른 클래스에서 쉽게 참조할 수 있도록 한다.
        + 그리고, 현재의 클래스를 다른 클래스로 대체하기 위해 반드시 구현이 필요한 메소드 정보를 제공한다.
        + 인터페이스에 있는 메소드만 구현이 되면 클래스를 다른 클래스로 교체하여 사용할 수 있다.
        + 일반적으로 컴포넌트를 구성할 때 인터페이스와 클래스를 묶어서 구성하게 된다.
        + 컴포넌트는 특정한 기능을 다른 기능으로 쉽게 대처할 수 있도록 구성이 되어야하기 때문에 인터페이스 정보는 필수적이다.
        + 외부의 다른 클래스에서 활용가능한 메소드는 인터페이스에 기술되어 있기 때문에 인터페이스에 있는 정보만 참조하면 된다.
        + 인터페이스를 활용하여 클래스 정보의 추상화, 캡슐화가 가능하다.
        + 그림에서 NameServiceImpl 클래스에 많은 메소드가 있지만 NameService 인터페이스를 Type으로 활용하고 클래스 인스턴스를 생성하게 되면 다른 메소드들은 참조할 수 없고, 인터페이스에 기술된 getName()만 참조가 가능하다.
        + 자바에서 클래스 인스턴스를 생성할 때 별도 인터페이스를 생성하지 않고 클래스 자체를 Type으로 생성할 수 있으나, 인터페이스를 활용하는 경우 다른 클래스에서 참조 가능한 메소드만 표현하고, 다른 메소드들은 노출시키지 않아도 되기 때문에 활용이 편리하다.
        
        ![image](https://user-images.githubusercontent.com/73324807/114121018-960b5a00-9928-11eb-946d-e1d63b33a443.png)

        
        + 인터페이스는 동작에 관련된 처리 로직 등의 코드가 포함되어 있지 않고, 구현을 위한 메소드 명, 입출력 Type 등 형식만 정의한다.
        ![image-2.png](attachment:image-2.png)
        
        + 앞의 설명에서 String 값의 id를 입력 변수로 가지고, 결과값을 String 값으로 반환하는 getName() 메소드를 가지는 NameService 인터페이스는 다음과 같이 작성된다.
        ![image-3.png](attachment:image-3.png)
        
        + 클래스는 인터페이스 정보를 참조하여 정의되어 있는 메소드는 반드시 구현해야 한다. 만약 구현하지 않으면 에러가 발생된다. NameService 인터페이스를 참조하여 구현한 NameServiceImpl 클래스는 다음과 같이 작성된다.
        ![image-4.png](attachment:image-4.png)
        
        + NamerServiceImpl의 메소드를 다른 클래스는 NamerServiceApp에서 참조하기 위해서 NamveService 인터페이스를 Type 으로 가지는 클래스 인스턴스와 클래스자체를 Type으로 가지는 클래스 인스턴스를 생성하면 다음과 같다.
        ![image-5.png](attachment:image-5.png)
        ![image-6.png](attachment:image-6.png)
        
        + 하나의 클래스에 여러 개의 인터페이스를 활용하는 경우 클래스의 메소드를 호출하는 클래스에 따라 다르게 노출시킬 수 있다. 이 경우에는 어떤 인터페이스를 Type으로 활용하여 클래스 인스턴스를 생성하는지에 따라 외부에 어떤 메소드가 노출되는 지 결정된다. 그림은 하나의 클래스 NameServiceImpl에 두 개 의 인터페이스를 활용하는 형태이다. CustomerService 인터페이스에서 getCustomer()만 메소드로 가지고 있기 때문에 CustomerService를 Type으로 생성된 클래스 인스턴스에서는 getCustomer()만 호출하여 활용이 가능하다. 이 경우 Class에서 제공하는 메소드를 호출 활용하는 클래스에 따라 다르게 노출시켜 활용할 수 있도록 캡슐화 하게 된다.
        ![image-7.png](attachment:image-7.png)
        
        + 자바 인터페이스를 활용하는 다른 사례로는 하나의 인터페이스에 클래스가 다수 존재하는 경우
        + 흔히 컴포넌트를 만드는 가장 중요한 이유로는 현재 구현된 기능을 다른 기능으로 쉽게 교체하여 활용할 수 있도록 하는 것
        + 인터페이스를 같은 것으로 활용하는 클래스가 있다면 기존 코드의 수정 없이 그대로 교체하여 활용할 수 있다.
        + 컴포넌트 기반의 개발에서는 인터페이스를 잘 설계하고 이를 활용하여 개발하는 것이 중요
        + 인터페이스가 잘 설계되어 있으면 특정한 기능의 모듈을 상황에 따라 교체하여 활용하는 것이 가능해진다.
        + 대표적인 예로 JDBC 드라이버의 경우 Oracle, MySQL 등 활용하는 DB가 달라져도 같은 역할을 수행해야 하므로 인터페이스를 준수하는 것이 필수적이다. 다음과 같이 두 개의 클래스 OracleImpl과 MySQLImpl가 하나의 인터페이스 DBService 인터페이스에 정의된 두 개의 함수 connect와 select는 반드시 구현이 되어야 한다. 하나의 인터페이스를 참조하고 있기 때문에 두 개의 클래스는 서로가 교체가 되어도 다른 코드에는 영향을 미치지 않게 된다.
        + 만약 인터페이스를 Type으로 선언하지 않고, 클래스로 Type을 선언하였다면 클래스를 교체할 때 두 개의 클래스 Type이 동일해야만 하는 지를 먼저 확인해야 한다. 클래스 Type이 일치하는 경우는 클래스 전체 함수나 변수 등이 일치해야 되기 때문에 새로운 동일 Type 클래스를 작성하거나 Type이 같은 지를 확인하는 작업은 인터페이스를 활용하는 경우에 비해 매우 어렵다.
        ![image-8.png](attachment:image-8.png)
        
        

6. DI
    2. DI개념
        + 인터페이스를 활용하는 경우 동일한 Type을 유지할 수 있어 컴포넌트 구현과 활용에 유리하다.
        + 특정한 클래스를 활용하다가 비즈니스 로직 변경 필요 등의 이유로 다른 클래스로 교체해야하는 경우가 발생될 수 있다.
        + 보편적인 방법은 new로 생성된 클래스를 직접 변경하는 것이다.
        + 만약 참조하고 있는 클래스가 수십개, 수백개가 되는 경우 굉장히 어려운 작업이 될 것이다.
        + 만약 클래스의 소스코드가 없는 경우는 어떻게 해야할 것인가? 
        + 이 때 등장한 개념이 DI(Dependency Injection)
        + DI는 클래스 인스턴스를 생성할 클래스를 직접 소스코드에 지정하지 않고 인터페이스를 활용하여 Type만 지정한다.
        + XML설정파일이나 annotation을 활용하여 실제 인스턴스를 생성할 클래스를 지정하게 된다.
        + 만약 다른 클래스로 교체를 해야 되는 경우에는 소스코드를 수정할 필요가 없이 XML 설정 팡리이나 annotation 정보를 수정하여 적용이 가능하다. Spring을 활용하지 않는 일반 자바 환경이라면 컴파일시에는 에러가 발생되지 않으나, 실행 시에 Class Not Found 에러가 발생하게 된다.
        + Spring이 동작하면서 설정파일이나 Annotation에 등록된 클래스 정보를 읽어서 동작시점에 Dependency를 생성하게 된다.
        + DI를 활용해서 소스코드에서 new를 해주는 것과 같은 효과를 어플리케이션이 동작하는 시점에 동적으로 생성할 수 있다. 그림에서 DI를 활용하지 않을 때는 new의 형태로 클래스 인스턴스를 생성하게 되어 있어 다른 클래스로 교체하기 위해서는 소스코드 수정이 필요하다. DI를 활용하는 경우에는 XML설정이나 annotation을 변경하여 Mapping정보를 변경하는 형태로 소스코드 변경이 없이 다른 클래스로 교체가 가능하다. 비즈니스 로직 변화가 많은 환경에서 소스코드의 수정없이 변경에 유연해진다. 클래스가 다른 클래스들 간의 의존성을 소스코드 레벨에서 가지지 않고 설정파일을 변경하여 의존성 변경이 가능해진다. 특정한 기능을 컴포넌트 형태로 만들어서 쉽게 교체해야 되는 경우 효율적으로 활용될 수 있다.
        ![image.png](attachment:image.png)
        + Spring Container는 객체를 생성하고, 객체 간의 의존성을 이어줄 수 있도록 필요한 정보를 제공
        + 이러한 객체를 Bean이라고 부르며, Spring 프레임워크에서 동작하는 모든 객체는 Bean단위로 활용된다.
        + 어플리케이션이 동작하는 시점에 XML이나 annotation으로 설정된 정보를 Spring Container에 저장하고, 설정 정보를 활용하여 DI를 수행하여 결과적으로 Spring에서 활용가능한 객체 형태인 bean을 생성하게 된다.
        + 소스코드 레벨에서는 클래스가 어떤 클래스를 참조하고 있는 지 알 수 없고, 어플리케이션이 동작하는 시점에 설정파일을 통해서 클래스에 대한 의존성이 결정되게 되므로 이를 IoC(Inversion of Control)이라고 한다.
        + 클래스 의존성의 결정이 소스코드에 있지 않고 외부에서 결정되어 활용되는 형태로 일반적인 어플리케이션이 동작과 반대되는 개념으로 IoC(제어의 역전)라고 불린다.
        ![image-2.png](attachment:image-2.png)
        + Spring Container의 정보는 ApplicationContext에 의해 관리된다. ApplicationContext는 Bean 생성 및 DI, 생명주기를 관리하는 BeanFactory의 기능과 Spring AOP, 메시지 리소스 처리, 이벤트 처리 등의 기능을 제공. ApplicationContext는 BeanFactory의 기능을 모두 제공하므로 일반적으로 ApplicationContext를 활용한다. Spring Container 정보를 생성하고 "foo"라는 bean을 찾는 방법은 다음과 같다. 다수의 Spring 설정 파일(Bean 설정, AOP 설정, 트랜잭션 설정, Data source 설정 등)을 일겅서 context를 생성하여 활용한다.
        ![image-3.png](attachment:image-3.png)
        

6. DI
    3. DI 활용
        + DI를 설정하기 위해 활용하는 방법으로 XML을 활용하는 방법과 annotation을 활용하는 방법
        + XML을 활용하는 방법은 설정이 불편하고 어려운 단점, XML 파일만 분석시 모든 클래스들 간의 의존성을 파악할 수 있는 장점
        + Annotation의 경우 소스코드에 annotation이 산재되어 있어 의존성 파악은 어려운 점, 편리한 설정 활용.
        + XML 설정의 경우 Spring 기반으로 구현된 솔루션, 플러그인, 프레임워크 등을 활용할 때 많이 활용되고, 일반 비즈니스 로직 구현은 annotation을 활용하는 것이 일반적이다.
        + 서비스 클래스는 비즈니스 로직을 처리하는 클래스.
        + DAO는 DB와 연동하여 정보를 처리하는 클래스로 표준프레임워크에서는 MyBatis(이전 버전 iBatis)를 활용하여 DB작업을 수행.
        ![image.png](attachment:image.png)
        + 비즈니스 로직인 웹 어플리케이션의 경우 Controller클래스에서 호출된다. 제일 처음 해야할 것은 인터페이스 구현.
        ![image-2.png](attachment:image-2.png)
        1. XML 설정을 활용한 DI
            + XML 설정파일은 <beans/>를 root로 가지며, <bean/>을 사용하여 의존성을 설정한다.
            + Spring Container에 여러 설정파일을 읽어 활용할 수 있기 때문에 설정 내용이 너무 많은 경우에는 XML 설정을 여러 개의 파일로 구성한다. 또한, DI, AOP, 트랜잭션, 메시지 등 설정 내용에 따라 개별 파일을 구성하는 것이 일반적이다. 다음의 XML설정은 두 개의 bean을 설정하고 있다. Bean은 id를 가지고 실제 클래스를 Mapping하고 있다. 클래스 정보는 Spring Container에 id와 함께 저장되어 어플리케이션이나 다른 bean에서 bean의 id로 해당 클래스 정보를 요청할 때 정보를 제공하게 된다. customerXML의 id를 가지는 bean은 실제 lab.CustomerXMLServiceImpl 클래스이며, property속성(custXMLDAO)이 정의 되어 bean id가 customerXMLDAO bean을 레퍼런스(ref)하고 있으며, 서비스 클래스에서 DAO클래스를 참조하기 위한 DI설정에 활용된다. 레퍼런스 되는 Bean은 id가 custoemrXMLDAO이고, 클래스는 lab.CustomerXMLDAO로 Mapping 되어 있다. Property이름은 클래스에서 클래스 정보를 받아오기 위해 정의하는 setter method에서 첫 글자를 대문자로 바꾸어 메소드 명으로 활용된다. 설정에서 customerXML의 경우 CustomerXMLServiceImpl 클래스의 setter 메소드 명으로 setCustXMLDAO으로 정의한다.
            ![image-3.png](attachment:image-3.png)
            
            + XML로 DI를 설정하는 클래스 CustomerXMLServiceImpl은 인터페이스를 참조하여 구현되며, 인터페이스에 설정된 두 개의 메소드 getCustName과 getCustGrade를 반드시 구현해야 한다. DAO를 호출하여 전달 받은 결과 값을 반환하도록 구현 되었다. private CustoemrXMLDAO xmlDAO; 로 Type만 선언되어 있고, new로 인스턴스 생성이 되지 않았는데 xmlDAO.getCustName(id)의 형태로 메소드를 호출하고 있다. Spring을 쓰지 않는 환경이라면 실행시점에 Class Not Found 에러가 발생되는데, DI를 활용하여 설정에 있는 클래스 정보를 setter method에서 치환하여 new를 실행한 것과 같이 인스턴스를 생성하게 된다. setCustXMLDAO에서 cmlDAO의 변수로 XML설정파일에 property로 설정 되어 있는 클래스 정보 (lab.CustomerXMLDAO)를 읽어와서 매핑하게 된다.
            
            ![image-4.png](attachment:image-4.png)
            
            + DAO는 서비스에서 호출되어 전달 받은 문자 값에 “ eGovFrame XML”과 “ S XML”을 추가하여 반환하도록 되어 있다. XML설정에는 bean id가 customerXMLDAO로 설정되어 있고, 실제 클래스는 lab.CustomerXMLDAO이며 DI를 위해 서비스 클래스에 property 속성으로 레퍼런스 되어 있다.
            ![image-5.png](attachment:image-5.png)
        2. Annotation 설정을 활용한 DI
            + Annotation은 소스코드에 직접 코딩을 하는 것이 아니라 @의 형태로 메타데이터를 삽입하는 것을 의미한다. 비즈니스로 로직에는 영향을 주지 않고 소스코드에 대한 실행이나 설정 정보를 추가한다. Annotation을 활용하여 DI를 설정하기 위해서는 Spring에서 annotation 활용을 위한 component-scan 정보를 설정해주어야 한다. Spring Container가 실행 될 때 base package 하위 소스코드의 Annotation 정보를 읽어서 Spring Container에 저장한다. 아래 설정(context-common.xml)에서는 패키지 lab 이하의 모든 소스코드를 스캔하여 annotation 정보를 획득하여 Spring Container에 저장하게 된다.
            
            ![image-6.png](attachment:image-6.png)
            
            + Bean을 설정하기 위해 클래스 위에 역할별로 annotation을 기술한다. 비즈니스 로직을 구현하는 서비스 클래스는 @Service, DAO는 @Repository로 정의 한다. MVC에서 소개하게 되는 Controller 클래스에는 @Controller를 정의한다. Bean 이름은 @Service(“customer”) 와 같이 정의하며, 이름이 지정되지 않으면 클래스 이름의 첫 글자를 소문자로 바꾸어 자동으로 지정한다. 설정된 bean 정보를 활용하여 DI를 설정하기 위해서는 @Resource나 @Autowired를 활용한다. Private CustomerAnnotationDAO customerdao;의 형태로 Type이 지정되어 있으나 new로 인스턴스를 생성하지 않고, @Resource(name=”custoerdao”)의 형태로 DI를 수행하였다. @Resource의 경우에는 bean의 이름을 지정하여 DI가 가능하며, @Autowired의 경우에는 같은 Type (Interface)를 활용하는 class를 자동으로 매핑하여 DI를 수행한다. 같은 Type이 다수 존재하는 경우는 에러가 발생되므로 유의하여야 한다. XML설정과 annotation설정을 통한 DI는 서로 교차도 가능하다. 즉 XML로 설정된 bean을 annotation을 활용하여 DI를 설정할 수 있고, 반대로 annotation으로 설정된 bean을 XML을 활용하여 DI 설정할 수 있다. Annotation을 활용한 DI 설정은 다음 그림과 같다. @Controller, @Service, @Repository로 bean이 설정되어 있고, 이를 DI로 활용하기 위해 @Resource로 참조 설정 되었다.
            
            ![image-7.png](attachment:image-7.png)
            
            + @Service를 활용하여 customer 이름으로 bean이 설정되어 있다. Customerdao 이름으로 설정된 DAO bean을 활용하기 위해 @Resource로 참조 설정 하였다.
            
            ![image-8.png](attachment:image-8.png)
            
            + @Repository를 활용하여 customerdao 이름으로 bean이 설정되어 있다. 서비스 클래스에서 @Resource로 참조 설정되고 메소드 호출 된다.
            ![image-9.png](attachment:image-9.png)
            
        3. Client 어플리케이션 실행
            + CustomerXMLServiceImpl이 동작하는지 확인하기 위해서 getCustName과 getCustGrade를 호출하는 자바 어플리케이션을 작성 한다. 자바 어플리케이션은 만들어진 서비스를 활용하는 Client 역할을 수행하기 때문에 XML이나 Annotation을 통한 DI 설정을 하지 않고, Spring Container에서 bean을 검색하여 정보를 얻어오는 형태로 활용하게 된다. XML이나 Annotation을 활용하여 DI설정을 하는 경우는 클래스간 연관이 높으면서 변경 가능성이 있는 경우에 변경 유연성을 높이기 위해서이다. 다른 클래스에서 기능만 호출하여 사용하는 경우는 연관성을 없애는 것이 중요하다. 이러한 경우 CustomerServiceApp 클래스 에서와 같이 Spring Container에서 bean id로 검색하고 bean 정보를 얻어오게 지원하면 기능 제공자와 사용자 간의 loosely coupling 된 형태로 의존성을 없애고 유연하게 활용할 수 있다.
            
            ![image-10.png](attachment:image-10.png)
            ![image-11.png](attachment:image-11.png)
            
            + 어플리케이션을 실행하면 다음과 같이 결과가 출력되는 것을 확인할 수 있다. XML에서는 id를 “1”로 전달 했고, annotation에서는 id를 “2”로 전달하여 서비스 클래스와 DAO 클래스를 거쳐서 결과 값을 전달 받았음을 확인 할 수 있다. 빨간색으로 에러 표시가 되는 부분은 로그를 생성할 log4j파일이 없어서 발생되는 것으로 제7장에서 학습하게 되며, 실행에는 지장이 없다.
            
            ![image-12.png](attachment:image-12.png)
            
        4. Test 코드 실행
            + 단위테스트는 소스코드의 중요 로직의 메소드를 실행시켜서 결과를 확인 할 수 있도록 한다. 메소드의 실행결과가 특정한 값으로 예상되는 경우 일치하는지 여부를 확인하여 일치하면 테스트가 Pass 되어 아무런 메시지가 출력되지 않지만, 일치하지 않는 경우는 에러메시지를 출력하게 된다. 이를 위해 표준프레임워크에서는 JUnit을 활용하여 테스트 케이스를 작성하여 실행한다. 먼저, spring-test와 JUnit 라이브러리 설정을 확인하여야 한다. pom.xml에 다음과 같이 의존성 설정이 되어 있는지 확인한다.
            ![image-13.png](attachment:image-13.png)
            + Maven 기반 디렉터리 구조에서 테스트를 위해 src/test/java와 src/test/resources가 정의되어 있다. Test 코드는 src/test/java 밑에 위치하게 되며, 테스트에서 활용되는 설정파일은 src/test/resources 밑에 정의되어야 한다. 따라서 src/main/resources에 있는 설정파일을 src/test/resources 밑으로 copy해야 한다. Spring 프레임워크에서 JUnit을 지원하기 위해 Spring Container를 실행할 수 있도록 annotation 기반 기능을 제공하고 있다. @RunWith은 Spring 기반으로 JUnit을 실행하도록 Runner를 지정하는 역할을 하고 있다. @ContextConfiguration은 경로에 해당되는 설정파일을 읽어서 Spring Container를 생성하여 JUnit 테스트 프로그램에서 접근하여 활용될 수 있도록 한다. 테스트케이스들은 @Test의 형식으로 설정되어 메소드를 직접 호출하지 않아도 JUnit이 실행될 때 자동으로 실행된다. 테스트 결과를 판별하기 위해 수행이 정상적일 때 결과값과 실제 수행된 결과값을 비교하여 두 개가 같을 경우에는 아무런 동작도 하지 않으나, 다를 경우 테스트 실패라는 에러 메시지를 출력하게 된다. assertEquals의 경우 예상 결과 값과 실제 수행된 결과 값을 비교하여 두 값이 다를 경우 에러메시지를 출력한다. 이외에도 assertNotEquals, assertTrue, assertFalse, assertNull, assertNotNull 등 많은 메소드를 제공하고 있다. 테스트를 수행하기 전후에 데이터의 준비, 결과값 처리 등 필요한 작업이 있을 경우 테스트케이스 수행 전 후에 자동으로 실행 될 수 있도록 @BeforeClass, @AfterCalss, @Before, @After의 annotation을 제공하고 있다. JUnit에서 활용되는 annotation들은 다음 표와 같다.
            ![image-14.png](attachment:image-14.png)
            ![image-15.png](attachment:image-15.png)
            + 앞에서 어플리케이션으로 실행되었던 Customer서비스 실행을 JUnit으로 실행하게 되면 다음과 같다. @ContextConfiguration에서는 test 환경에서 활용될 설정 파일 위치를 지정하게 되며, src/test/resources 밑의 설정 정보를 읽어오게 된다. JUnit이 실행되게 되면 @Test로 설정되어 있는 테스트케이스가 실행되게 되며, assertEquals가 실행되어 예상 값과 결과 값을 비교하여 결과를 출력하게 된다.
            ![image-16.png](attachment:image-16.png)
            + 테스트 코드의 실행은 CustomerServiceTest.java를 선택하고 마우스 오른쪽 버튼을 눌러서 Run As > JUnit Test를 선택하여 실행한다. 테스트가 성공한 경우에는 아무런 출력이 없이 녹색 막대가 보여지게 된다. 테스트가 실패한 경우에는 실패 메시지와 함께 빨간색 막대를 보게 된다. 테스트 실패의 경우는 에러가 발생된 경우와 정상적으로 실행은 되었으나 assert 문의 조건을 만족하지 못하는 경우 발생된다. (assertEquals의 경우 예상 값과 수행 결과 값이 다른 경우 실패)
            ![image-19.png](attachment:image-19.png)
            ![image-18.png](attachment:image-18.png)

































































